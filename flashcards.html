<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BERXY0M3FY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BERXY0M3FY');
  </script>

  <!-- Basic Page Needs -->
  <meta charset="utf-8">
  <title>Flashcards Probabilités - Hadrien Bigo-Balland</title>
  <meta name="description" content="Flashcards pour étudier les probabilités">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/animate.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/dot.png">

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <style>
    /* Fix for horizontal scrolling issue */
    html, body {
      overflow-x: hidden;
      width: 100%;
      position: relative;
    }

    /* Flashcard container adjustments to prevent overflow */
    .cards-carousel {
      /* ...existing code... */
      width: 100%;
      max-width: 100%;
      left: 0;
      overflow: visible; /* Keep this to show adjacent cards */
      /* Center the carousel with auto margins */
      margin-left: auto;
      margin-right: auto;
    }

    /* Prevent adjacent cards from causing horizontal scrolling */
    .carousel-track {
      /* ...existing code... */
      /* Ensure track container doesn't expand beyond viewport width */
      max-width: 100%;
      overflow: visible;
      transform-style: preserve-3d; /* Help with 3D transformations */
    }

    /* Fix positioning of the rotated cards to avoid horizontal scrollbar */
    .flashcard-container.prev {
      /* Use 3D transforms which don't affect document flow */
      transform: translate3d(30px, 0, -50px) scale(0.85) rotate(-5deg);
      z-index: 1;
    }

    .flashcard-container.next {
      /* Use 3D transforms which don't affect document flow */
      transform: translate3d(-30px, 0, -50px) scale(0.85) rotate(5deg);
      z-index: 1;
    }

    .flashcard-container.active {
      z-index: 2;
      /* Use 3D transform to ensure proper stacking */
      transform: translate3d(0, 0, 0) scale(1);
    }

    /* Adjust container to prevent overflow */
    .container {
      /* ...existing code... */
      overflow-x: hidden; /* Prevent horizontal scrolling in container */
      max-width: 100%; /* Ensure container doesn't exceed viewport width */
    }
    
    /* Media query for mobile devices - adjusted positioning */
    @media (max-width: 550px) {
      .flashcard-container.prev {
        transform: translate3d(15px, 0, -30px) scale(0.85) rotate(-3deg);
      }
      
      .flashcard-container.next {
        transform: translate3d(-15px, 0, -30px) scale(0.85) rotate(3deg);
      }
    }

    /* Flashcard specific styles */
    .flashcard-container {
      min-width: 100%;
      padding: 0 20px;
      margin: 0;
      box-sizing: border-box;
      flex-shrink: 0;
      perspective: 1000px;
      opacity: 0.3;
      transform: scale(0.85);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .flashcard-container.active {
      opacity: 1;
      transform: scale(1);
    }
    
    .flashcard-container.prev,
    .flashcard-container.next {
      opacity: 0.6;
      transform: scale(0.9);
    }

    .flashcard {
      width: 100%;
      min-height: 300px;
      transform-style: preserve-3d;
      transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      margin: 0 auto;
    }

    .flipped {
      transform: rotateY(180deg);
    }

    .card-face {
      position: absolute;
      width: 100%;
      min-height: 300px;
      height: 100%;
      border-radius: 12px;
      padding: 30px;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    body.day .card-face {
      background-color: white;
      color: #403E43;
    }

    body.night .card-face {
      background-color: #2D2D32;
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
    }

    .card-face.front {
      z-index: 2;
    }

    .card-face.back {
      transform: rotateY(180deg);
    }

    .card-content {
      text-align: center;
      max-width: 500px;
      font-family: NeueHaas;
      font-size: 18px;
      line-height: 1.5;
      transition: opacity 0.3s ease;
    }

    .card-number {
      position: absolute;
      bottom: 15px;
      right: 15px;
      font-size: 12px;
      opacity: 0.6;
      font-family: NeueHaasMedium;
    }

    .card-hint {
      position: absolute;
      bottom: 15px;
      left: 15px;
      font-size: 12px;
      opacity: 0.6;
      font-family: NeueHaas;
    }

    /* Header section - Matching central-limit-theorem.html styling */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    
    .back-info-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header {
      display: flex;
      align-items: center;
      margin-bottom: 0;
    }

    .title {
      margin: 0;
      font-family: NeueHaasMedium;
      font-size: 20px;
      letter-spacing: .25px;
      line-height: 28px;
    }

    .back-link {
      text-decoration: none;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid;
      transition: all 0.2s ease;
      background-color: transparent;
      padding: 0;
      margin: 0;
      line-height: 1;
      transform: translateY(0px);
    }

    .back-link:before {
      content: "←";
      transition: transform 0.2s ease;
      font-size: 14px;
    }

    .back-link:hover:before {
      transform: translateX(-2px);
    }

    body.day .back-link {
      color: #403E43;
      border-color: #999;
    }

    body.night .back-link {
      color: #C8C8C9;
      border-color: #666;
    }

    body.day .back-link:hover {
      border-color: #666;
    }

    body.night .back-link:hover {
      border-color: #999;
    }

    /* Theme toggle */
    .theme-toggle {
      display: flex;
      align-items: center;
    }

    body.night #moon {
      display: none;
    }

    body.day #moon {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.night #sun {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.day #sun {
      display: none;
    }

    /* Animations */
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }

    .bounce-hint {
      animation: bounce 2s ease infinite;
      position: absolute;
      bottom: 50px;
      left: calc(50% - 8px);
      font-size: 16px;
      opacity: 0.5;
    }

    /* Animation for card content */
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Content transitions */
    .content-hidden {
      opacity: 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 767px) {
      .card-face {
        padding: 20px;
        min-height: 250px;
      }
      
      .card-content {
        font-size: 16px;
      }
      
      .title {
        font-size: 18px;
      }
    }
    
    @media (max-width: 480px) {
      .card-face {
        padding: 15px;
        min-height: 230px;
      }
      
      .card-content {
        font-size: 15px;
      }
    }
    
    @media (max-width: 550px) {
      .back-info-container {
        margin-bottom: 20px;
      }
    }

    /* Keyboard shortcuts guide styling */
    .keyboard-shortcuts {
      width: 100%;
      max-width: 400px;
      margin: 20px auto;
      padding: 0;
      text-align: center;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .keyboard-shortcuts:hover {
      opacity: 1;
    }

    .shortcuts-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 8px;
    }

    .shortcut-item {
      display: flex;
      align-items: center;
      font-family: NeueHaas;
      font-size: 14px;
    }

    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      padding: 0 6px;
      margin-right: 8px;
      border-radius: 4px;
      font-family: NeueHaasMedium;
      font-size: 13px;
      letter-spacing: 0;
      transition: all 0.2s ease;
    }

    body.day .key {
      background-color: #f1f1f2;
      border: 1px solid #ddd;
      color: #403E43;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05), inset 0 -1px 0 rgba(0,0,0,0.1);
    }

    body.night .key {
      background-color: #333;
      border: 1px solid #444;
      color: #C8C8C9;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2), inset 0 -1px 0 rgba(0,0,0,0.3);
    }

    .shortcut-label {
      font-size: 13px;
    }

    /* Separating line */
    .shortcut-separator {
      margin: 10px 0 15px;
      width: 40px;
      height: 1px;
      background: linear-gradient(90deg, transparent, currentColor, transparent);
      opacity: 0.2;
      margin: 10px auto 15px;
    }

    @media (max-width: 480px) {
      .shortcuts-container {
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
    }

    /* MathJax responsive styles for better equation wrapping */
    .card-content .MathJax {
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      vertical-align: middle;
    }
    
    .card-content .large-equation {
      overflow-x: auto;
      padding-bottom: 10px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    
    @media (max-width: 480px) {
      .card-face {
        padding: 15px 10px;
      }
      
      .card-content {
        font-size: 14px;
        width: 100%;
        overflow-wrap: break-word;
      }
      
      .card-content .MathJax_SVG_Display {
        overflow-x: auto;
        padding-bottom: 5px;
      }
    }

    /* Card carousel container - completely removing any potential borders */
    .cards-carousel {
      position: relative;
      width: 100%;
      min-height: 350px;
      overflow: visible; /* Keep this to show adjacent cards */
      margin: 48px auto;
      /* Remove all possible borders/frames */
      border: none;
      box-shadow: none;
      background-color: transparent;
      outline: none;
    }
    
    /* Carousel track - ensuring no frame elements */
    .carousel-track {
      position: relative;
      display: flex;
      transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
      width: 100%;
      height: 100%;
      will-change: transform;
      padding: 20px 0;
      /* Remove any frame elements */
      border: none;
      outline: none;
      box-shadow: none;
      background-color: transparent;
    }

    /* Progress dots for carousel - enhanced styling */
    .carousel-dots {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 30px 0 10px; /* Increased top margin now that bar is removed */
      padding-bottom: 10px;
    }
    
    .carousel-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    body.night .carousel-dot {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .carousel-dot.active {
      width: 24px;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    body.night .carousel-dot.active {
      background-color: rgba(255, 255, 255, 0.5);
    }
    
    /* Navigation arrow buttons - positioned more visibly */
    .nav-arrows {
      position: absolute;
      top: 0;
      left: -50px; /* Extended outward to make more room */
      width: calc(100% + 100px); /* Widened to accommodate the outward arrows */
      height: 100%;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10;
    }
    
    .nav-arrow {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto;
      transition: all 0.3s ease;
      opacity: 0.7;
    }
    
    body.night .nav-arrow {
      background-color: rgba(50, 50, 55, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
    }
    
    .nav-arrow:hover {
      opacity: 1;
      transform: scale(1.05);
    }
    
    .nav-arrow:active {
      transform: scale(0.98);
    }
    
    .nav-arrow.prev::before {
      content: "←";
      font-size: 18px;
    }
    
    .nav-arrow.next::before {
      content: "→";
      font-size: 18px;
    }
    
    body.day .nav-arrow {
      color: #403E43;
    }
    
    body.night .nav-arrow {
      color: #C8C8C9;
    }

    /* REMOVE side gradients completely as they're likely causing the frame effect */
    .cards-carousel::before, .cards-carousel::after {
      display: none;
    }

    /* Enhanced card visual cues to show adjacent cards better */
    .flashcard-container.prev {
      transform: translateX(30px) scale(0.85) rotate(-5deg);
      z-index: 1;
    }

    .flashcard-container.next {
      transform: translateX(-30px) scale(0.85) rotate(5deg);
      z-index: 1;
    }

    .flashcard-container.active {
      z-index: 2;
    }

    /* Remove any container boundaries */
    .container {
      overflow: visible; /* Ensure no clipping of rotated cards */
      /* Remove potential window-causing elements */
      border: none;
      box-shadow: none;
      background: none;
    }

    /* Ensure flashcard containers have no frames */
    .flashcard-container {
      /* Remove any potential borders */
      border: none;
      outline: none;
      box-shadow: none;
      background: none;
    }
    
    /* Position the navigation outside the cards on wider screens */
    @media (min-width: 768px) {
      .cards-carousel {
        width: 80%;
      }
      
      .nav-arrows {
        left: -60px;
        width: calc(100% + 120px);
      }
    }
    
    /* Media query for mobile devices - simplified positioning */
    @media (max-width: 550px) {
      .nav-arrows {
        left: -20px;
        width: calc(100% + 40px);
      }
      
      .flashcard-container.prev {
        transform: translateX(15px) scale(0.85) rotate(-3deg);
      }
      
      .flashcard-container.next {
        transform: translateX(-15px) scale(0.85) rotate(3deg);
      }
    }

    /* Enhanced mobile experience - hide arrows and optimize for touch */
    @media (max-width: 767px) {
      /* Hide navigation arrows on mobile */
      .nav-arrows {
        display: none;
      }

      /* Hide keyboard shortcuts on mobile */
      .keyboard-shortcuts {
        display: none;
      }
      
      /* Make carousel more touch-friendly */
      .cards-carousel {
        touch-action: pan-y; /* Allow vertical scrolling but improve horizontal swipe detection */
        min-height: 320px; /* Slightly reduce card height on mobile */
      }
      
      /* Optimize card size for mobile viewing */
      .card-face {
        min-height: 260px; /* Slightly reduce card height */
      }
      
      /* Make sure adjacent cards are visible as swipe cues */
      .flashcard-container.prev {
        transform: translate3d(20px, 0, -30px) scale(0.85) rotate(-3deg);
        opacity: 0.7; /* Make more visible as a swipe hint */
      }
      
      .flashcard-container.next {
        transform: translate3d(-20px, 0, -30px) scale(0.85) rotate(3deg);
        opacity: 0.7; /* Make more visible as a swipe hint */
      }

      /* Add swipe hint animation on page load */
      @keyframes swipeHint {
        0%, 100% { transform: translateX(0); }
        50% { transform: translateX(-15px); }
      }
      
      .swipe-hint {
        position: absolute;
        bottom: -40px;
        left: 0;
        width: 100%;
        text-align: center;
        font-size: 12px;
        opacity: 0.6;
        animation: swipeHint 1.5s ease-in-out 3;
        font-family: NeueHaas;
        pointer-events: none;
      }
      
      /* Style swipe hint for dark/light theme */
      body.day .swipe-hint {
        color: #403E43;
      }
      
      body.night .swipe-hint {
        color: #C8C8C9;
      }
      
      /* Optimize animations for performance */
      .carousel-track {
        transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      }
      
      /* Make dots easier to tap */
      .carousel-dot {
        width: 10px;
        height: 10px;
        margin: 0 5px;
      }
      
      .carousel-dot.active {
        width: 28px;
      }
    }
    
    /* Very small screens - further optimization */
    @media (max-width: 480px) {
      .cards-carousel {
        min-height: 300px;
      }
      
      .card-face {
        min-height: 240px;
        padding: 15px 12px;
      }
      
      .card-content {
        font-size: 14px;
      }
    }
  </style>
  
  <!-- Script for day/night theme management -->
  <script>
  $(document).ready(function(){
      // Event handlers for day/night buttons
      $("#moon").click(function(){
          $("body").removeClass("day");
          $("body").addClass("night");
          localStorage.setItem('theme', 'night');
      });
      
      $("#sun").click(function(){
          $("body").removeClass("night");
          $("body").addClass("day");
          localStorage.setItem('theme', 'day');
      });
      
      // Apply stored theme
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme) {
          if (storedTheme === 'night') {
              $("body").removeClass("day");
              $("body").addClass("night");
          } else {
              $("body").addClass("day");
              $("body").removeClass("night");
          }
      }

      // Add swipe hint only on mobile
      if (window.innerWidth <= 767) {
        $('.cards-carousel').append('<div class="swipe-hint">Swipez pour naviguer</div>');
        
        // Hide the swipe hint after 6 seconds
        setTimeout(function() {
          $('.swipe-hint').fadeOut(500);
        }, 6000);
      }
  });
  </script>

  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        macros: {
          // Add common abbreviations to save space
          R: '{\\mathbb{R}}',
          E: '{\\mathbb{E}}',
          P: '{\\mathbb{P}}'
        }
      },
      svg: {
        fontCache: 'global'
      },
      // Enable line breaks in equations
      linebreaks: {
        automatic: true,
        width: "container"
      },
      // Make MathJax responsive
      responsive: {
        breakpoints: {
          xs: 0,
          sm: 480,
          md: 768
        }
      }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

</head>

<body class="day">
  <div class="container">
    <!-- Header -->
    <div class="header-container">
      <div class="back-info-container">
        <a href="index.html" class="back-link"></a>
      </div>
      <div class="theme-toggle">
        <img src="images/sun.svg" id="moon">
        <img src="images/moon.svg" id="sun">
      </div>
    </div>

    <!-- Title section -->
    <div class="header">
      <h1 class="title">Flashcards Probabilités</h1>
    </div>

    <!-- Card carousel structure -->
    <div class="cards-carousel">
      <div class="carousel-track" id="carousel-track">
        <!-- Flashcard containers will be inserted here dynamically -->
      </div>
      
      <!-- Navigation arrows -->
      <div class="nav-arrows">
        <div class="nav-arrow prev" id="prev-arrow"></div>
        <div class="nav-arrow next" id="next-arrow"></div>
      </div>
    </div>
    
    <!-- Carousel dots indicator -->
    <div class="carousel-dots" id="carousel-dots">
      <!-- Dots will be generated dynamically -->
    </div>
    
    <!-- Keyboard shortcuts guide -->
    <div class="keyboard-shortcuts">
      <div class="shortcut-separator"></div>
      <div class="shortcuts-title">Raccourcis clavier</div>
      <div class="shortcuts-container">
        <div class="shortcut-item">
          <span class="key">←</span>
          <span class="shortcut-label">Précédent</span>
        </div>
        <div class="shortcut-item">
          <span class="key">→</span>
          <span class="shortcut-label">Suivant</span>
        </div>
        <div class="shortcut-item">
          <span class="key">Espace</span>
          <span class="shortcut-label">Retourner</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Tableau de données pour les flashcards
    var flashcards = [
    {
      question: "Qu'est-ce qu'un événement aléatoire ?",
      answer: "Un événement aléatoire est quelque chose qui peut se produire. On cherche à savoir quelle est la chance qu'il se produise. Par exemple, 'mon bus arrivera dans 2 min' est un événement aléatoire."
    },
    {
      question: "Qu'est-ce qu'une probabilité ?",
      answer: "C'est un nombre entre 0 et 1 qui indique à quel point un événement a de chance de se produire : 0 pour impossible, 1 pour quasi certain."
    },
    {
      question: "Qu'est-ce que l'événement complémentaire d'un événement $A$ ?",
      answer: "C'est l'événement qui correspond à 'A ne se produit pas'. Il est noté $\\overline{A}$, et sa probabilité vaut $P(\\overline{A}) = 1 - P(A)$."
    },
    {
      question: "Quelle est la formule de la probabilité dans un cas équiprobable ?",
      answer: "$P(\\text{événement}) = \\frac{\\text{nombre de cas favorables}}{\\text{nombre total de cas}}$"
    },
    {
      question: "Qu'est-ce que l'intersection de deux événements $A$ et $B$ ?",
      answer: "L'intersection $A \\cap B$ représente la situation où les deux événements se produisent en même temps."
    },
    {
      question: "Qu'est-ce que l'union de deux événements $A$ et $B$ ?",
      answer: "L'union $A \\cup B$ représente l'événement 'A ou B ou les deux se produisent'."
    },
    {
      question: "Quelle est la formule pour l'union de deux événements $A$ et $B$ ?",
      answer: "$P(A \\cup B) = P(A) + P(B) - P(A \\cap B)$"
    },
    {
      question: "Qu'est-ce que des événements incompatibles ?",
      answer: "Des événements sont incompatibles s'ils ne peuvent pas se produire ensemble : $P(A \\cap B) = 0$."
    },
    {
      question: "Qu'est-ce que des événements indépendants ?",
      answer: "Deux événements sont indépendants si la réalisation de l'un n'influence pas la probabilité de l'autre : $P_A(B) = P(B)$."
    },
    {
      question: "Comment calcule-t-on une probabilité conjointe si les événements sont indépendants ?",
      answer: "Si $A$ et $B$ sont indépendants, alors $P(A \\cap B) = P(A) \\times P(B)$."
    },
    {
      question: "Quelle est la formule de la probabilité conditionnelle de $B$ sachant $A$ ?",
      answer: "$P_A(B) = \\frac{P(A \\cap B)}{P(A)}$, si $P(A) \\ne 0$."
    },
    {
      question: "Quelle est la version conjointe de la formule des probabilités totales ?",
      answer: "Si $(B_i)$ forme une partition, alors:<div class='large-equation'>$P(A) = P(A \\cap B_1) + P(A \\cap B_2) + \\ldots + P(A \\cap B_n)$</div>"
    },
    {
      question: "Quelle est la version conditionnelle de la formule des probabilités totales ?",
      answer: "Si $(B_i)$ forme une partition, alors:<div class='large-equation'>$P(A) = P_{B_1}(A)P(B_1) + P_{B_2}(A)P(B_2) + \\ldots + P_{B_n}(A)P(B_n)$</div>"
    },
    {
      question: "Énonce le théorème de Bayes.",
      answer: "$P_B(A) = \\frac{P(A)P_A(B)}{P(B)} = \\frac{P(A \\cap B)}{P(B)}$"
    },
    {
      question: "Qu'est-ce qu'un tableau de contingence ?",
      answer: "C'est un tableau qui croise deux variables aléatoires pour représenter des probabilités conjointes et calculer les marginales et conditionnelles."
    },
    {
      question: "Comment calcule-t-on une probabilité conditionnelle à partir d'un tableau de contingence ?",
      answer: "En divisant une case par la somme de sa ligne ou colonne : $P_A(B) = \\frac{P(A \\cap B)}{P(A)}$"
    },
    {
      question: "Qu'est-ce qu'un arbre de probabilité ?",
      answer: "C'est une représentation graphique des différentes issues possibles d'une expérience aléatoire, avec les probabilités sur les branches."
    },
    {
      question: "Quelle est la règle pour calculer la probabilité d'un chemin dans un arbre ?",
      answer: "C'est le produit des probabilités le long du chemin."
    },
    {
      question: "Quelle est la loi de Bernoulli ?",
      answer: "Une variable $X \\sim \\mathcal{B}(p)$ prend 1 avec probabilité $p$ et 0 avec probabilité $1 - p$."
    },
    {
      question: "Quelle est l'espérance et la variance d'une Bernoulli $\\mathcal{B}(p)$ ?",
      answer: "$\\mathbb{E}(X) = p$, $\\text{Var}(X) = p(1 - p)$"
    },
    {
      question: "Quelle est la loi binomiale ?",
      answer: "$X \\sim \\mathcal{B}(n, p)$ modélise le nombre de succès dans $n$ répétitions indépendantes de Bernoulli."
    },
    {
      question: "Quelle est la formule de masse de la loi binomiale ?",
      answer: "$P(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi binomiale $\\mathcal{B}(n, p)$ ?",
      answer: "$\\mathbb{E}(X) = np$, $\\text{Var}(X) = np(1 - p)$"
    },
    {
      question: "Qu'est-ce que la loi de Poisson ?",
      answer: "Elle modélise un nombre d'événements rares dans un intervalle : $P(X = k) = \\frac{e^{-\\lambda} \\lambda^k}{k!}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi de Poisson $\\mathcal{P}(\\lambda)$ ?",
      answer: "$\\mathbb{E}(X) = \\lambda$, $\\text{Var}(X) = \\lambda$"
    },
    {
      question: "Qu'est-ce qu'une loi uniforme continue $\\mathcal{U}(a,b)$ ?",
      answer: "Une loi où toutes les valeurs entre $a$ et $b$ ont la même densité : $f(x) = \\frac{1}{b-a}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi uniforme $\\mathcal{U}(a,b)$ ?",
      answer: "$\\mathbb{E}(X) = \\frac{a + b}{2}$, $\\text{Var}(X) = \\frac{(b - a)^2}{12}$"
    },
    {
      question: "Quelle est la densité de la loi normale $\\mathcal{N}(\\mu, \\sigma^2)$ ?",
      answer: "$f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2} \\left( \\frac{x - \\mu}{\\sigma} \\right)^2}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi normale $\\mathcal{N}(\\mu, \\sigma^2)$ ?",
      answer: "$\\mathbb{E}(X) = \\mu$, $\\text{Var}(X) = \\sigma^2$"
    },
    {
      question: "Quand utilise-t-on le test du $\\chi^2$ ?",
      answer: "Pour tester si deux variables qualitatives sont indépendantes (dans un tableau de contingence)."
    },
    {
      question: "Quelle est la formule de la statistique $\\chi^2$ ?",
      answer: "$\\chi^2 = \\sum \\frac{(O_{ij} - E_{ij})^2}{E_{ij}}$"
    },
    {
      question: "Quelle est la formule des effectifs attendus pour un test $\\chi^2$ ?",
      answer: "$E_{ij} = \\frac{\\text{Total ligne}_i \\times \\text{Total colonne}_j}{\\text{Total général}}$"
    },
    {
      question: "Quelle est la statistique du test de Student ?",
      answer: "$t = \\frac{\\bar{x} - \\mu_0}{s / \\sqrt{n}}$"
    },
    {
      question: "Quand utilise-t-on le test de Student ?",
      answer: "Pour comparer la moyenne d'un échantillon à une moyenne théorique $\\mu_0$."
    }
  ];

  $(document).ready(function() {
    var currentCardIndex = 0;
    var animationInProgress = false;
    
    // Initialize carousel by creating all cards
    function initializeCarousel() {
      const carouselTrack = $('#carousel-track');
      const dotContainer = $('#carousel-dots');
      
      // Clear track
      carouselTrack.empty();
      dotContainer.empty();
      
      // Generate all flashcard elements
      flashcards.forEach((card, index) => {
        // Create flashcard container
        const cardContainer = $(`
          <div class="flashcard-container ${index === currentCardIndex ? 'active' : ''}">
            <div class="flashcard">
              <div class="card-face front">
                <div class="card-content">${card.question}</div>
                <div class="card-number">${index + 1} / ${flashcards.length}</div>
                <div class="card-hint">Cliquez pour voir la réponse</div>
                ${index === 0 ? '<div class="bounce-hint">↓</div>' : ''}
              </div>
              <div class="card-face back">
                <div class="card-content">${card.answer}</div>
                <div class="card-number">${index + 1} / ${flashcards.length}</div>
                <div class="card-hint">Cliquez pour voir la question</div>
              </div>
            </div>
          </div>
        `);
        
        // Append card to track
        carouselTrack.append(cardContainer);
        
        // Add corresponding dot
        const dot = $(`<div class="carousel-dot ${index === currentCardIndex ? 'active' : ''}"></div>`);
        dotContainer.append(dot);
        
        // Add click handler to dot
        dot.on('click', function() {
          if (!animationInProgress && index !== currentCardIndex) {
            goToCard(index);
          }
        });
      });
      
      // Add click handler to flip cards
      $('.flashcard').on('click', function() {
        const cardIndex = $(this).closest('.flashcard-container').index();
        if (cardIndex === currentCardIndex) {
          flipCurrentCard();
        }
      });
      
      // Set appropriate relative positions for prev/active/next cards
      updateCardClasses();
      
      // Process MathJax for all cards at once
      if (window.MathJax) {
        MathJax.typesetPromise().then(() => {
          // Add indicators for overflowing equations
          checkAndAddScrollIndicators();
        }).catch((err) => console.log('MathJax error:', err));
      }
    }
    
    // Update current card and adjacent card classes
    function updateCardClasses() {
      $('.flashcard-container').removeClass('active prev next');
      
      // Set active card
      $(`.flashcard-container:eq(${currentCardIndex})`).addClass('active');
      
      // Set previous card if available
      if (currentCardIndex > 0) {
        $(`.flashcard-container:eq(${currentCardIndex - 1})`).addClass('prev');
      }
      
      // Set next card if available
      if (currentCardIndex < flashcards.length - 1) {
        $(`.flashcard-container:eq(${currentCardIndex + 1})`).addClass('next');
      }
      
      // Update track position to center the current card
      updateTrackPosition();
      
      // Update dots
      $('.carousel-dot').removeClass('active');
      $(`.carousel-dot:eq(${currentCardIndex})`).addClass('active');
    }
    
    // Position the track to center the current card
    function updateTrackPosition() {
      const translateX = -100 * currentCardIndex;
      $('#carousel-track').css('transform', `translateX(${translateX}%)`);
    }
    
    // Go to a specific card with animation
    function goToCard(index) {
      if (animationInProgress) return;
      if (index < 0 || index >= flashcards.length) return;
      
      animationInProgress = true;
      
      // Update current card index
      currentCardIndex = index;
      
      // Update card classes which handles the track position
      updateCardClasses();
      
      // Ensure card is showing front face
      $(`.flashcard-container:eq(${currentCardIndex})`).find('.flashcard').removeClass('flipped');
      
      // Update progress bar
      updateProgressBar();
      
      // Release animation lock after transition completes
      setTimeout(() => {
        animationInProgress = false;
      }, 600); // Match the transition duration
    }
    
    // Flip the current card
    function flipCurrentCard() {
      if (animationInProgress) return;
      
      const currentCard = $(`.flashcard-container:eq(${currentCardIndex})`).find('.flashcard');
      const isFrontVisible = !currentCard.hasClass('flipped');
      
      // Remove bounce hint after first click
      $(".bounce-hint").fadeOut(300);
      
      // Flip the card
      if (isFrontVisible) {
        currentCard.addClass('flipped');
      } else {
        currentCard.removeClass('flipped');
      }
    }
    
    // Go to next card
    function nextCard() {
      if (currentCardIndex < flashcards.length - 1) {
        goToCard(currentCardIndex + 1);
      }
    }
    
    // Go to previous card
    function previousCard() {
      if (currentCardIndex > 0) {
        goToCard(currentCardIndex - 1);
      }
    }
    
    // Update progress bar - remove this function as we no longer have a progress bar
    function updateProgressBar() {
      // Progress bar was removed, so this function can be empty
      // We keep it to avoid breaking existing code that calls it
    }
    
    // Highlight key animation
    function highlightKey(keyName) {
      // Find the key element with matching text content
      $(".key").each(function() {
        if ($(this).text() === keyName) {
          const key = $(this);
          // Add a highlight class
          key.css({
            "transform": "translateY(2px)",
            "opacity": "0.7"
          });
          
          // Remove it after animation completes
          setTimeout(function() {
            key.css({
              "transform": "",
              "opacity": ""
            });
          }, 200);
        }
      });
    }
    
    // Check for overflowing equations
    function checkAndAddScrollIndicators() {
      $('.card-content .MathJax_SVG_Display').each(function() {
        if (this.scrollWidth > this.clientWidth) {
          $(this).css('cursor', 'ew-resize');
        }
      });
    }
    
    // Initialize the carousel
    initializeCarousel();
    updateProgressBar();
    
    // Set up navigation arrow handlers
    $('#prev-arrow').on('click', function() {
      if (!animationInProgress) {
        previousCard();
        highlightKey("←");
      }
    });
    
    $('#next-arrow').on('click', function() {
      if (!animationInProgress) {
        nextCard();
        highlightKey("→");
      }
    });
    
    // Keyboard navigation
    $(document).keydown(function(e) {
      if (animationInProgress) return;
      
      // Right arrow for next
      if (e.key === "ArrowRight") {
        nextCard();
        highlightKey("→");
      } 
      // Left arrow for previous
      else if (e.key === "ArrowLeft") {
        previousCard();
        highlightKey("←");
      } 
      // Space, Enter, ArrowUp or ArrowDown to flip
      else if (e.key === " " || e.key === "Space" || e.key === "Enter" || 
              e.key === "ArrowUp" || e.key === "ArrowDown") {
        flipCurrentCard();
        highlightKey("Espace");
        // Prevent page scroll on spacebar
        if (e.key === " " || e.key === "Space") {
          e.preventDefault();
        }
      }
    });
    
    // Add touch swipe support
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let swipeThreshold = 50; // Increase threshold for more deliberate swipes
    let isMobile = window.innerWidth <= 767;
    
    $('.cards-carousel')
      .on('touchstart', function(e) {
        touchStartX = e.originalEvent.touches[0].clientX;
        touchStartY = e.originalEvent.touches[0].clientY;
        
        // Add active state to improve touch feedback
        if (isMobile) {
          $(this).css('opacity', '0.98');
        }
      })
      .on('touchmove', function(e) {
        // If we're in a transition, don't interfere
        if (animationInProgress) return;
        
        // Optional: add a subtle real-time translation to follow finger
        // for more responsive feel on mobile
        if (isMobile) {
          const currentX = e.originalEvent.touches[0].clientX;
          const deltaX = currentX - touchStartX;
          
          // Only if the swipe is more horizontal than vertical
          const currentY = e.originalEvent.touches[0].clientY;
          const deltaY = Math.abs(currentY - touchStartY);
          
          if (Math.abs(deltaX) > deltaY && Math.abs(deltaX) < 50) {
            // Small visual feedback while dragging
            const trackTransform = -100 * currentCardIndex + (deltaX * 0.1);
            $('#carousel-track').css('transform', `translateX(${trackTransform}%)`);
          }
        }
      })
      .on('touchend', function(e) {
        if (animationInProgress) return;
        
        // Reset opacity
        if (isMobile) {
          $(this).css('opacity', '');
        }
        
        touchEndX = e.originalEvent.changedTouches[0].clientX;
        touchEndY = e.originalEvent.changedTouches[0].clientY;
        
        // Calculate swipe distance
        const swipeDistanceX = touchEndX - touchStartX;
        const swipeDistanceY = Math.abs(touchEndY - touchStartY);
        
        // Only proceed if swipe was more horizontal than vertical and exceeded threshold
        if (Math.abs(swipeDistanceX) > swipeDistanceY && Math.abs(swipeDistanceX) > swipeThreshold) {
          if (swipeDistanceX > 0) {
            // Swipe right - go to previous card
            previousCard();
          } else {
            // Swipe left - go to next card
            nextCard();
          }
        } else {
          // Reset position if swipe wasn't significant
          updateTrackPosition();
        }
      })
      .on('touchcancel', function() {
        // Reset position on touch cancel
        updateTrackPosition();
        
        // Reset opacity
        if (isMobile) {
          $(this).css('opacity', '');
        }
      });
    
    // Handle orientation change to optimize layout
    window.addEventListener('orientationchange', function() {
      // Wait for orientation change to complete
      setTimeout(function() {
        isMobile = window.innerWidth <= 767;
        updateTrackPosition();
      }, 300);
    });
    
    // ...rest of your existing code...
  });
  </script>
</body>
</html>