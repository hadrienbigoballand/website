<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BERXY0M3FY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BERXY0M3FY');
  </script>

  <!-- Basic Page Needs -->
  <meta charset="utf-8">
  <title>Flashcards Probabilités - Hadrien Bigo-Balland</title>
  <meta name="description" content="Flashcards pour étudier les probabilités">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preload" href="fonts/NHaasGroteskTXPro-55Rg.ttf" as="font" type="font/ttf" crossorigin>
  <link rel="preload" href="fonts/NHaasGroteskTXPro-65Md.ttf" as="font" type="font/ttf" crossorigin>

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.min.css">
  <link rel="stylesheet" href="css/skeleton.min.css">
  <link rel="stylesheet" href="css/main.min.css">
  <link rel="stylesheet" href="css/animate.min.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/dot.png">

  <!-- jQuery -->
  <script defer src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <style>
    /* Fix for horizontal scrolling issue */
    html, body {
      overflow-x: hidden;
      width: 100%;
      position: relative;
    }

    /* Flashcard container adjustments to prevent overflow */
    .cards-carousel {
      /* ...existing code... */
      width: 100%;
      max-width: 100%;
      left: 0;
      overflow: visible; /* Keep this to show adjacent cards */
      /* Center the carousel with auto margins */
      margin-left: auto;
      margin-right: auto;
    }

    /* Prevent adjacent cards from causing horizontal scrolling */
    .carousel-track {
      /* ...existing code... */
      /* Ensure track container doesn't expand beyond viewport width */
      max-width: 100%;
      overflow: visible;
      transform-style: preserve-3d; /* Help with 3D transformations */
    }

    /* Fix positioning of the rotated cards to avoid horizontal scrollbar */
    .flashcard-container.prev {
      /* Use 3D transforms which don't affect document flow */
      transform: translate3d(30px, 0, -50px) scale(0.85) rotate(-5deg);
      z-index: 1;
    }

    .flashcard-container.next {
      /* Use 3D transforms which don't affect document flow */
      transform: translate3d(-30px, 0, -50px) scale(0.85) rotate(5deg);
      z-index: 1;
    }

    .flashcard-container.active {
      z-index: 2;
      /* Use 3D transform to ensure proper stacking */
      transform: translate3d(0, 0, 0) scale(1);
    }

    /* Adjust container to prevent overflow */
    .container {
      /* ...existing code... */
      overflow-x: hidden; /* Prevent horizontal scrolling in container */
      max-width: 100%; /* Ensure container doesn't exceed viewport width */
    }
    
    /* Media query for mobile devices - adjusted positioning */
    @media (max-width: 550px) {
      .flashcard-container.prev {
        transform: translate3d(15px, 0, -30px) scale(0.85) rotate(-3deg);
      }
      
      .flashcard-container.next {
        transform: translate3d(-15px, 0, -30px) scale(0.85) rotate(3deg);
      }
    }

    /* Flashcard specific styles */
    .flashcard-container {
      min-width: 100%;
      padding: 0 20px;
      margin: 0;
      box-sizing: border-box;
      flex-shrink: 0;
      perspective: 1000px;
      opacity: 0.3;
      transform: scale(0.85);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .flashcard-container.active {
      opacity: 1;
      transform: scale(1);
    }
    
    .flashcard-container.prev,
    .flashcard-container.next {
      opacity: 0.6;
      transform: scale(0.9);
    }

    .flashcard {
      width: 100%;
      min-height: 300px;
      transform-style: preserve-3d;
      transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      margin: 0 auto;
    }

    .flipped {
      transform: rotateY(180deg);
    }

    .card-face {
      position: absolute;
      width: 100%;
      min-height: 300px;
      height: 100%;
      border-radius: 12px;
      padding: 30px;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      box-sizing: border-box;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    body.day .card-face {
      background-color: white;
      color: #403E43;
    }

    body.night .card-face {
      background-color: #2D2D32;
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
    }

    .card-face.front {
      z-index: 2;
    }

    .card-face.back {
      transform: rotateY(180deg);
    }

    .card-content {
      text-align: center;
      max-width: 500px;
      font-family: NeueHaas;
      font-size: 18px;
      line-height: 1.5;
      transition: opacity 0.3s ease;
      display: inline-block;
      width: 100%;
    }

    .card-number {
      position: absolute;
      bottom: 15px;
      right: 15px;
      font-size: 12px;
      opacity: 0.6;
      font-family: NeueHaasMedium;
    }

    .card-hint {
      position: absolute;
      bottom: 15px;
      left: 15px;
      font-size: 12px;
      opacity: 0.6;
      font-family: NeueHaas;
    }

    /* Header section - Matching central-limit-theorem.html styling */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    
    .back-info-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .header {
      display: flex;
      align-items: center;
      margin-bottom: 0;
    }

    .title {
      margin: 0;
      font-family: NeueHaasMedium;
      font-size: 20px;
      letter-spacing: .25px;
      line-height: 28px;
    }

    .back-link {
      text-decoration: none;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid;
      transition: all 0.2s ease;
      background-color: transparent;
      padding: 0;
      margin: 0;
      line-height: 1;
      transform: translateY(0px);
    }

    .back-link:before {
      content: "←";
      transition: transform 0.2s ease;
      font-size: 14px;
    }

    .back-link:hover:before {
      transform: translateX(-2px);
    }

    body.day .back-link {
      color: #403E43;
      border-color: #999;
    }

    body.night .back-link {
      color: #C8C8C9;
      border-color: #666;
    }

    body.day .back-link:hover {
      border-color: #666;
    }

    body.night .back-link:hover {
      border-color: #999;
    }

    /* Theme toggle */
    .theme-toggle {
      display: flex;
      align-items: center;
    }

    body.night #moon {
      display: none;
    }

    body.day #moon {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.night #sun {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.day #sun {
      display: none;
    }

    /* Animations */
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }

    .bounce-hint {
      animation: bounce 2s ease infinite;
      position: absolute;
      bottom: 50px;
      left: calc(50% - 8px);
      font-size: 16px;
      opacity: 0.5;
    }

    /* Animation for card content */
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Content transitions */
    .content-hidden {
      opacity: 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 767px) {
      .card-face {
        padding: 20px;
        min-height: 250px;
      }
      
      .card-content {
        font-size: 16px;
      }
      
      .title {
        font-size: 18px;
      }
    }
    
    @media (max-width: 480px) {
      .card-face {
        padding: 15px;
        min-height: 230px;
      }
      
      .card-content {
        font-size: 15px;
      }
    }
    
    @media (max-width: 550px) {
      .back-info-container {
        margin-bottom: 20px;
      }
    }

    /* Keyboard shortcuts guide styling */
    .keyboard-shortcuts {
      width: 100%;
      max-width: 400px;
      margin: 20px auto;
      padding: 0;
      text-align: center;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .keyboard-shortcuts:hover {
      opacity: 1;
    }

    .shortcuts-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 8px;
    }

    .shortcut-item {
      display: flex;
      align-items: center;
      font-family: NeueHaas;
      font-size: 14px;
    }

    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      padding: 0 6px;
      margin-right: 8px;
      border-radius: 4px;
      font-family: NeueHaasMedium;
      font-size: 13px;
      letter-spacing: 0;
      transition: all 0.2s ease;
    }

    body.day .key {
      background-color: #f1f1f2;
      border: 1px solid #ddd;
      color: #403E43;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05), inset 0 -1px 0 rgba(0,0,0,0.1);
    }

    body.night .key {
      background-color: #333;
      border: 1px solid #444;
      color: #C8C8C9;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2), inset 0 -1px 0 rgba(0,0,0,0.3);
    }

    .shortcut-label {
      font-size: 13px;
    }

    /* Separating line */
    .shortcut-separator {
      margin: 10px 0 15px;
      width: 40px;
      height: 1px;
      background: linear-gradient(90deg, transparent, currentColor, transparent);
      opacity: 0.2;
      margin: 10px auto 15px;
    }

    @media (max-width: 480px) {
      .shortcuts-container {
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
    }

    /* MathJax responsive styles for better equation wrapping */
    .card-content .MathJax {
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      vertical-align: middle;
    }
    
    .card-content .large-equation {
      overflow-x: auto;
      padding-bottom: 10px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    
    @media (max-width: 480px) {
      .card-face {
        padding: 15px 10px;
      }
      
      .card-content {
        font-size: 14px;
        width: 100%;
        overflow-wrap: break-word;
      }
      
      .card-content .MathJax_SVG_Display {
        overflow-x: auto;
        padding-bottom: 5px;
      }
    }

    /* Card carousel container - completely removing any potential borders */
    .cards-carousel {
      position: relative;
      width: 100%;
      min-height: 350px;
      overflow: visible; /* Keep this to show adjacent cards */
      margin: 48px auto;
      /* Remove all possible borders/frames */
      border: none;
      box-shadow: none;
      background-color: transparent;
      outline: none;
    }
    
    /* Carousel track - ensuring no frame elements */
    .carousel-track {
      position: relative;
      display: flex;
      transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
      width: 100%;
      height: 100%;
      will-change: transform;
      padding: 20px 0;
      /* Remove any frame elements */
      border: none;
      outline: none;
      box-shadow: none;
      background-color: transparent;
    }

    /* Progress dots for carousel - enhanced styling */
    .carousel-dots {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 30px 0 10px; /* Increased top margin now that bar is removed */
      padding-bottom: 10px;
    }
    
    .carousel-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    body.night .carousel-dot {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .carousel-dot.active {
      width: 24px;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    body.night .carousel-dot.active {
      background-color: rgba(255, 255, 255, 0.5);
    }
    
    /* Navigation arrow buttons - positioned more visibly */
    .nav-arrows {
      position: absolute;
      top: 0;
      left: -50px; /* Extended outward to make more room */
      width: calc(100% + 100px); /* Widened to accommodate the outward arrows */
      height: 100%;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10;
    }
    
    .nav-arrow {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto;
      transition: all 0.3s ease, opacity 0.3s ease, visibility 0.3s ease;
      opacity: 0.7;
      /* Add absolute positioning to both arrows */
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
    }
    
    /* Position each arrow at its respective side */
    .nav-arrow.prev {
      left: 0;
    }
    
    .nav-arrow.next {
      right: 0;
    }
    
    body.night .nav-arrow {
      background-color: rgba(50, 50, 55, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
    }
    
    .nav-arrow:hover {
      opacity: 1;
    }
    
    .nav-arrow:active {
    }
    
    .nav-arrow.prev::before {
      content: "←";
      font-size: 18px;
    }
    
    .nav-arrow.next::before {
      content: "→";
      font-size: 18px;
    }
    
    body.day .nav-arrow {
      color: #403E43;
    }
    
    body.night .nav-arrow {
      color: #C8C8C9;
    }

    /* REMOVE side gradients completely as they're likely causing the frame effect */
    .cards-carousel::before, .cards-carousel::after {
      display: none;
    }

    /* Enhanced card visual cues to show adjacent cards better */
    .flashcard-container.prev {
      transform: translateX(30px) scale(0.85) rotate(-5deg);
      z-index: 1;
    }

    .flashcard-container.next {
      transform: translateX(-30px) scale(0.85) rotate(5deg);
      z-index: 1;
    }

    .flashcard-container.active {
      z-index: 2;
    }

    /* Remove any container boundaries */
    .container {
      overflow: visible; /* Ensure no clipping of rotated cards */
      /* Remove potential window-causing elements */
      border: none;
      box-shadow: none;
      background: none;
    }

    /* Ensure flashcard containers have no frames */
    .flashcard-container {
      /* Remove any potential borders */
      border: none;
      outline: none;
      box-shadow: none;
      background: none;
    }
    
    /* Position the navigation outside the cards on wider screens */
    @media (min-width: 768px) {
      .cards-carousel {
        width: 80%;
      }
      
      .nav-arrows {
        left: -60px;
        width: calc(100% + 120px);
      }
    }
    
    /* Media query for mobile devices - simplified positioning */
    @media (max-width: 550px) {
      .nav-arrows {
        left: -20px;
        width: calc(100% + 40px);
      }
      
      .flashcard-container.prev {
        transform: translateX(15px) scale(0.85) rotate(-3deg);
      }
      
      .flashcard-container.next {
        transform: translateX(-15px) scale(0.85) rotate(3deg);
      }
    }

    /* Enhanced mobile experience - using feature queries instead of just width */
    @media (hover: none) and (pointer: coarse) {
      /* Hide navigation arrows on touch devices */
      .nav-arrows {
        display: none;
      }

      /* Hide keyboard shortcuts on touch devices */
      .keyboard-shortcuts {
        display: none;
      }
      
      /* Make carousel more touch-friendly */
      .cards-carousel {
        touch-action: pan-y; /* Allow vertical scrolling but improve horizontal swipe detection */
        min-height: 320px; /* Slightly reduce card height on mobile */
      }
      
      /* Optimize card size for touch viewing */
      .card-face {
        min-height: 260px; /* Slightly reduce card height */
      }
      
      /* Make sure adjacent cards are visible as swipe cues */
      .flashcard-container.prev {
        transform: translate3d(20px, 0, -30px) scale(0.85) rotate(-3deg);
        opacity: 0.7; /* Make more visible as a swipe hint */
      }
      
      .flashcard-container.next {
        transform: translate3d(-20px, 0, -30px) scale(0.85) rotate(3deg);
        opacity: 0.7; /* Make more visible as a swipe hint */
      }
      
      /* Add swipe hint animation on page load */
      @keyframes swipeHint {
        0%, 100% { transform: translateX(0); }
        50% { transform: translateX(-15px); }
      }
      
      .swipe-hint {
        position: absolute;
        bottom: -40px;
        left: 0;
        width: 100%;
        text-align: center;
        font-size: 12px;
        opacity: 0.6;
        animation: swipeHint 1.5s ease-in-out 3;
        font-family: NeueHaas;
        pointer-events: none;
      }
      
      /* Style swipe hint for dark/light theme */
      body.day .swipe-hint {
        color: #403E43;
      }
      
      body.night .swipe-hint {
        color: #C8C8C9;
      }
      
      /* Optimize animations for performance */
      .carousel-track {
        transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      }
      
      /* Make dots easier to tap on touch devices */
      .carousel-dot {
        width: 10px;
        height: 10px;
        margin: 0 5px;
      }
      
      .carousel-dot.active {
        width: 28px;
      }
    }

    /* Redesigned mobile disclaimer styling for a more discreet appearance */
    .mobile-disclaimer {
      display: none; /* Hidden by default, shown via JS for mobile only */
      margin: 10px auto 20px;
      padding: 10px 15px;
      border-radius: 8px;
      font-family: NeueHaas;
      font-size: 13px;
      line-height: 1.4;
      max-width: 100%;
      box-sizing: border-box;
      transition: all 0.3s ease;
      text-align: center;
      border-width: 1px;
      border-style: solid;
      opacity: 0.85; /* More transparent for subtlety */
    }

    body.day .mobile-disclaimer {
      background-color: rgba(64, 62, 67, 0.03);
      border-color: rgba(64, 62, 67, 0.08);
      color: #6a6875;
    }

    body.night .mobile-disclaimer {
      background-color: rgba(255, 255, 255, 0.03);
      border-color: rgba(255, 255, 255, 0.08);
      color: #a7a7a8;
    }

    .disclaimer-emoji {
      font-size: 13px;
      margin-right: 5px;
      opacity: 0.8;
    }

    /* Remove animations and dismiss button styles as they're no longer needed */

    /* Enhanced mobile hints styling */
    .mobile-hints {
      position: absolute;
      bottom: -60px;
      left: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      pointer-events: none;
    }
    
    .swipe-hint, .tap-hint {
      width: 100%;
      text-align: center;
      font-size: 12px;
      opacity: 0.7;
      font-family: NeueHaas;
    }
    
    /* Style hints for dark/light theme */
    body.day .swipe-hint, body.day .tap-hint {
      color: #403E43;
    }
    
    body.night .swipe-hint, body.night .tap-hint {
      color: #C8C8C9;
    }
    
    /* Improved swipe animation that continues indefinitely */
    @keyframes swipeHint {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(-15px); }
    }
    
    .swipe-hint {
      animation: swipeHint 2s ease-in-out infinite;
    }
    
    /* New tap animation that continues indefinitely */
    @keyframes tapHint {
      0%, 100% { transform: translateY(0); }
      40% { transform: translateY(-3px); }
      60% { transform: translateY(0); }
    }
    
    .tap-hint {
      animation: tapHint 2s ease-in-out infinite;
    }
    
    /* Ensure hints only show on touch devices */
    .mobile-hints {
      display: none;
    }
    
    @media (hover: none) and (pointer: coarse) {
      .mobile-hints {
        display: flex;
      }
      
      .cards-carousel {
        margin-bottom: 70px; /* Add space for the hints */
      }
    }

    /* Enhanced swipe effect and feedback */
    .carousel-track.swiping {
      transition: none; /* Remove transition during active swiping for immediate feedback */
    }
    
    /* Visual indicator for active swipe direction */
    .swipe-direction-indicator {
      position: absolute;
      top: 50%;
      opacity: 0;
      background-color: rgba(0, 0, 0, 0.1);
      height: 50px;
      width: 50px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #fff;
      z-index: 50;
      pointer-events: none;
      transform: translateY(-50%);
      transition: opacity 0.2s ease;
    }
    
    body.night .swipe-direction-indicator {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .swipe-left-indicator {
      left: 20px;
    }
    
    .swipe-right-indicator {
      right: 20px;
    }
    
    .swipe-left-indicator.active,
    .swipe-right-indicator.active {
      opacity: 0.8;
      animation: pulse 0.8s infinite alternate;
    }
    
    @keyframes pulse {
      0% { transform: translateY(-50%) scale(1); }
      100% { transform: translateY(-50%) scale(1.1); }
    }
    
    /* Flashcard transition enhancement */
    .flashcard-container.fast-transition {
      transition: all 0.25s cubic-bezier(0.19, 1, 0.22, 1) !important;
    }

    /* Enhanced carousel navigation bar - replaces dots */
    .carousel-nav {
      position: relative;
      width: 100%;
      max-width: 500px;
      height: 40px;
      margin: 40px auto 20px;
      padding: 0 15px;
      box-sizing: border-box;
    }
    
    .progress-track {
      position: relative;
      width: 100%;
      height: 4px;
      background-color: rgba(0, 0, 0, 0.1);
      border-radius: 2px;
      margin-top: 18px;
      cursor: pointer;
      overflow: visible;
    }
    
    body.night .progress-track {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .progress-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      border-radius: 2px;
      transition: width 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    }
    
    body.night .progress-fill {
      background-color: rgba(255, 255, 255, 0.4);
    }
    
    /* Navigation markers that represent cards */
    .nav-marker {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
      cursor: pointer;
      z-index: 2;
    }
    
    body.night .nav-marker {
      background-color: rgba(255, 255, 255, 0.15);
    }
    
    .nav-marker:hover {
      transform: translate(-50%, -50%) scale(1.5);
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    body.night .nav-marker:hover {
      background-color: rgba(255, 255, 255, 0.5);
    }
    
    .nav-marker.active {
      width: 12px;
      height: 12px;
      background-color: rgba(0, 0, 0, 0.6);
    }
    
    body.night .nav-marker.active {
      background-color: rgba(255, 255, 255, 0.6);
    }
    
    /* Elegant tooltip for question preview - reduced size */
    .card-tooltip {
      position: absolute;
      top: -12px; /* Slightly closer to the marker */
      left: 50%;
      transform: translateX(-50%) translateY(-100%) scale(0.95);
      background-color: white;
      color: #403E43;
      padding: 7px 10px; /* Reduced padding */
      border-radius: 6px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1); /* Smaller shadow */
      font-size: 11px; /* Smaller font */
      font-family: NeueHaas;
      max-width: 180px; /* Reduced max width */
      width: max-content;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: 
        transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        opacity 0.2s ease,
        visibility 0s linear 0.2s;
      z-index: 100;
      pointer-events: none;
      line-height: 1.3; /* Slightly tighter line height */
    }
    
    body.night .card-tooltip {
      background-color: #2D2D32;
      color: #C8C8C9;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    }
    
    .nav-marker:hover .card-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-100%) scale(1);
      transition: 
        transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        opacity 0.3s ease,
        visibility 0s linear;
    }
    
    /* Arrow indicator on tooltip */
    .card-tooltip:after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 4px; /* Smaller arrow */
      border-style: solid;
      border-color: white transparent transparent transparent;
    }
    
    body.night .card-tooltip:after {
      border-color: #2D2D32 transparent transparent transparent;
    }
    
    /* Current position indicator */
    .position-indicator {
      position: absolute;
      top: -35px;
      left: 0;
      font-family: NeueHaasMedium;
      font-size: 13px;
      color: #403E43;
      opacity: 0.7;
      transition: left 0.4s cubic-bezier(0.22, 1, 0.36, 1), transform 0.3s ease;
      transform: translateX(-50%);
    }
    
    body.night .position-indicator {
      color: #C8C8C9;
    }

    /* Remove previous carousel dots as we're replacing them */
    .carousel-dots {
      display: none;
    }

    /* Make the carousel taller to accommodate the new navigation */
    .cards-carousel {
      margin-bottom: 80px;
    }

    /* Adaptive spacing for smaller screens */
    @media (max-width: 480px) {
      .carousel-nav {
        max-width: 100%;
        padding: 0 10px;
      }
      
      .card-tooltip {
        max-width: 150px; /* Even smaller on mobile */
        font-size: 10px;
        padding: 6px 8px;
      }
    }

    /* Elegant tooltip for question preview - even more reduced size */
    .card-tooltip {
      position: absolute;
      top: -10px; /* Even closer to marker */
      left: 50%;
      transform: translateX(-50%) translateY(-100%) scale(0.95);
      background-color: white;
      color: #403E43;
      padding: 5px 8px; /* More compact padding */
      border-radius: 5px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08); /* Lighter shadow */
      font-size: 10px; /* Smaller font */
      font-family: NeueHaas;
      max-width: 150px; /* Further reduced width */
      width: max-content;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: 
        transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        opacity 0.2s ease,
        visibility 0s linear 0.2s;
      z-index: 100;
      pointer-events: none;
      line-height: 1.2; /* Tighter line height */
      border: 1px solid rgba(0, 0, 0, 0.06); /* Ultra subtle border */
      letter-spacing: -0.1px; /* Slightly tighter kerning */
    }

    body.night .card-tooltip {
      background-color: #2D2D32;
      color: #C8C8C9;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.06); /* Ultra subtle border for night mode */
    }

    .nav-marker:hover .card-tooltip {
      opacity: 0.9; /* Slightly transparent even when visible */
      visibility: visible;
      transform: translateX(-50%) translateY(-100%) scale(1);
      transition: 
        transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        opacity 0.3s ease,
        visibility 0s linear;
    }

    /* Arrow indicator on tooltip - even smaller */
    .card-tooltip:after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 3px; /* Even smaller arrow */
      border-style: solid;
      border-color: white transparent transparent transparent;
    }

    body.night .card-tooltip:after {
      border-color: #2D2D32 transparent transparent transparent;
    }

    /* Subtle fade effect when tooltip appears */
    .nav-marker:hover .card-tooltip {
      animation: subtle-glow 0.4s ease-out;
    }

    @keyframes subtle-glow {
      0% { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05); }
      50% { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.12); }
      100% { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08); }
    }

    body.night .nav-marker:hover .card-tooltip {
      animation: subtle-glow-night 0.4s ease-out;
    }

    @keyframes subtle-glow-night {
      0% { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); }
      50% { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); }
      100% { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); }
    }

    /* Further adaptive spacing for smaller screens */
    @media (max-width: 480px) {
      .card-tooltip {
        max-width: 120px; /* Even smaller on mobile */
        font-size: 9px; /* Even smaller font */
        padding: 4px 6px; /* Minimum viable padding */
      }
    }

    /* Enhanced mobile experience with improved layout */
    @media (hover: none) and (pointer: coarse) {
      /* Adjust carousel bottom margin to accommodate repositioned elements */
      .cards-carousel {
        margin-bottom: 30px; /* Reduced from 70px since we'll reposition elements */
      }
      
      /* Reposition the navigation for mobile */
      .carousel-nav {
        margin-top: 25px; /* Space between cards and navbar */
        margin-bottom: 20px; /* Space between navbar and mobile hints */
        padding: 0 20px; /* Slightly increased padding for better appearance */
      }
      
      /* Reposition mobile hints below the navigation */
      .mobile-hints {
        position: relative; /* Change from absolute to relative */
        bottom: auto; /* Remove absolute positioning */
        margin-bottom: 25px; /* Add bottom margin */
        gap: 5px; /* Reduce gap between hints for more compact appearance */
      }
      
      /* Adjust visual style of mobile hints for more compact appearance */
      .swipe-hint, .tap-hint {
        font-size: 11px; /* Slightly smaller text */
        line-height: 1.3; /* Tighter line height */
        opacity: 0.8; /* Slightly more visible */
        letter-spacing: -0.2px; /* Tighter letter spacing */
      }
      
      /* Make the overall container taller to accommodate all elements */
      .container {
        padding-bottom: 20px; /* Add some bottom padding */
      }
      
      /* Override the nav position indicator placement for better mobile appearance */
      .position-indicator {
        top: -25px; /* Move up slightly */
        font-size: 12px; /* Slightly smaller for mobile */
      }
      
      /* Make the progress track slightly thicker on mobile for better touch targets */
      .progress-track {
        height: 5px;
      }
    }

    /* Enhanced back button styling with elegant glow effect */
    .back-link {
      text-decoration: none;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
      background-color: transparent;
      padding: 0;
      margin: 0;
      line-height: 1;
      position: relative;
      overflow: hidden;
    }

    .back-link:before {
      content: "←";
      transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
      font-size: 18px;
      z-index: 2;
      position: relative;
    }

    /* Subtle background glow effect */
    .back-link:after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      opacity: 0;
      transition: opacity 0.4s ease;
      border-radius: 50%;
      z-index: 1;
    }

    body.day .back-link {
      color: #403E43;
      border: 1px solid rgba(0, 0, 0, 0.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    body.night .back-link {
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    body.day .back-link:hover {
      border-color: rgba(0, 0, 0, 0.3);
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    body.night .back-link:hover {
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
      transform: translateY(-1px);
    }

    .back-link:hover:before {
      transform: translateX(-2px);
    }

    .back-link:hover:after {
      opacity: 0.2;
    }

    body.night .back-link:after {
      background: radial-gradient(circle, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 70%);
    }

    /* Enhanced title styling */
    .title {
      margin: 0;
      font-family: NeueHaasMedium;
      font-size: 24px;
      letter-spacing: 0.3px;
      line-height: 1.3;
      position: relative;
      transition: all 0.3s ease;
      padding-bottom: 4px;
      display: inline-block;
    }

    .title:after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 1px;
      background: currentColor;
      transition: width 0.4s cubic-bezier(0.22, 1, 0.36, 1);
      opacity: 0.6;
    }

    .header:hover .title:after {
      width: 100%;
    }

    /* Add subtle text shadow for glow effect */
    body.day .title {
      text-shadow: 0 0 1px rgba(0,0,0,0.01);
    }

    body.night .title {
      text-shadow: 0 0 2px rgba(255,255,255,0.1);
    }

    /* Updated header layout */
    .header {
      display: flex;
      align-items: center;
      margin-bottom: 30px;
      position: relative;
    }

    /* For devices smaller than 550px - align back button with theme toggle */
    @media (max-width: 550px) {
      .back-info-container {
        margin-bottom: 30px;
      }
      
      .title {
        font-size: 20px;
      }
    }

    /* Enhanced hidden state with !important flags for stronger hiding */
    .nav-arrow.hidden {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
      display: none !important; /* Force complete hiding */
    }
  </style>
  
  <!-- Script for day/night theme management -->
  <script>
  $(document).ready(function(){
      // Event handlers for day/night buttons
      $("#moon").click(function(){
          $("body").removeClass("day");
          $("body").addClass("night");
          localStorage.setItem('theme', 'night');
      });
      
      $("#sun").click(function(){
          $("body").removeClass("night");
          $("body").addClass("day");
          localStorage.setItem('theme', 'day');
      });
      
      // Apply stored theme
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme) {
          if (storedTheme === 'night') {
              $("body").removeClass("day");
              $("body").addClass("night");
          } else {
              $("body").addClass("day");
              $("body").removeClass("night");
          }
      }

      // Better mobile detection using feature detection
      function isTouchDevice() {
          return (('ontouchstart' in window) ||
              (navigator.maxTouchPoints > 0) ||
              (navigator.msMaxTouchPoints > 0));
      }

      // Alternative detection checking for mobile/tablet user agents
      function isMobileUserAgent() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }

      // Combined check that's more reliable than just width
      const isTouch = isTouchDevice() || isMobileUserAgent() || window.matchMedia('(hover: none) and (pointer: coarse)').matches;

      // Add mobile hints for touch devices
      if (isTouch) {
        // Remove the old approach of appending to cards-carousel
        // We'll now insert the hints after the disclaimer in showMobileDisclaimer()
        
        // Show mobile disclaimer - always display it
        showMobileDisclaimer();
      }

      // Function to show mobile disclaimer - modified to include hints
      function showMobileDisclaimer() {
          const disclaimer = $(`
              <div class="mobile-disclaimer">
                  <span class="disclaimer-emoji">💻</span>
                  Version optimisée pour ordinateur. Navigation tactile disponible. Si le swipe ne marche pas, rechargez la page.
              </div>
          `);
          
          // Create hints to be placed below disclaimer
          const hints = $(`
              <div class="mobile-top-hints">
                  <div class="top-tap-hint">Tapotez pour retourner la carte</div>
                  <div class="top-swipe-hint">Swipez pour naviguer</div>
              </div>
          `);
          
          // Insert after header
          $('.header').after(disclaimer);
          
          // Insert hints after disclaimer
          disclaimer.after(hints);
          
          // Show with subtle fade-in
          disclaimer.fadeIn(400);
      }
  });
  </script>

  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        macros: {
          // Add common abbreviations to save space
          R: '{\\mathbb{R}}',
          E: '{\\mathbb{E}}',
          P: '{\\mathbb{P}}'
        }
      },
      svg: {
        fontCache: 'global'
      },
      // Enable line breaks in equations
      linebreaks: {
        automatic: false,  // Changed from true to false to prevent automatic line breaks
        width: "container"
      },
      // Make MathJax responsive
      responsive: {
        breakpoints: {
          xs: 0,
          sm: 480,
          md: 768
        }
      },
      // Additional MathJax configuration to improve inline display
      displayAlign: 'center',
      displayIndent: '0',
      extensions: ["tex2jax.js"],
      "HTML-CSS": { 
        linebreaks: { automatic: false }  // Disable automatic linebreaks here too
      },
      CommonHTML: {
        linebreaks: { automatic: false }  // Disable automatic linebreaks in CommonHTML output
      }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

</head>

<body class="day">
  <div class="container">
    <!-- Header -->
    <div class="header-container">
      <div class="back-info-container">
        <a href="index.html" class="back-link"></a>
      </div>
      <div class="theme-toggle">
        <img loading="lazy" src="images/sun.svg" id="moon">
        <img loading="lazy" src="images/moon.svg" id="sun">
      </div>
    </div>

    <!-- Title section -->
    <div class="header">
      <h1 class="title">Flashcards Probabilités</h1>
    </div>
    
    <!-- Mobile disclaimer will be inserted here dynamically for touch devices -->

    <!-- Card carousel structure -->
    <div class="cards-carousel">
      <div class="carousel-track" id="carousel-track">
        <!-- Flashcard containers will be inserted here dynamically -->
      </div>
      
      <!-- Navigation arrows -->
      <div class="nav-arrows">
        <div class="nav-arrow prev" id="prev-arrow"></div>
        <div class="nav-arrow next" id="next-arrow"></div>
      </div>
    </div>
    
    <!-- Carousel dots indicator -->
    <div class="carousel-dots" id="carousel-dots">
      <!-- Dots will be generated dynamically -->
    </div>
    
    <!-- Keyboard shortcuts guide -->
    <div class="keyboard-shortcuts">
      <div class="shortcut-separator"></div>
      <div class="shortcuts-title">Raccourcis clavier</div>
      <div class="shortcuts-container">
        <div class="shortcut-item">
          <span class="key">←</span>
          <span class="shortcut-label">Précédent</span>
        </div>
        <div class="shortcut-item">
          <span class="key">→</span>
          <span class="shortcut-label">Suivant</span>
        </div>
        <div class="shortcut-item">
          <span class="key">Espace</span>
          <span class="shortcut-label">Retourner</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Tableau de données pour les flashcards
    var flashcards = [
    {
      question: "Qu'est-ce qu'un événement aléatoire ?",
      answer: "Un événement aléatoire est quelque chose qui peut se produire. On cherche à savoir quelle est la chance qu'il se produise. Par exemple, 'mon bus arrivera dans 2 min' est un événement aléatoire."
    },
    {
      question: "Qu'est-ce qu'une probabilité ?",
      answer: "C'est un nombre entre 0 et 1 qui indique à quel point un événement a de chance de se produire : 0 pour impossible, 1 pour quasi certain."
    },
    {
      question: "Qu'est-ce que l'événement complémentaire d'un événement $A$ ?",
      answer: "C'est l'événement qui correspond à 'A ne se produit pas'. Il est noté $\\overline{A}$, et sa probabilité vaut $P(\\overline{A}) = 1 - P(A)$."
    },
    {
      question: "Quelle est la formule de la probabilité dans un cas équiprobable ?",
      answer: "$P(\\text{événement}) = \\frac{\\text{nombre de cas favorables}}{\\text{nombre total de cas}}$"
    },
    {
      question: "Qu'est-ce que l'intersection de deux événements $A$ et $B$ ?",
      answer: "L'intersection $A \\cap B$ représente la situation où les deux événements se produisent en même temps."
    },
    {
      question: "Qu'est-ce que l'union de deux événements $A$ et $B$ ?",
      answer: "L'union $A \\cup B$ représente l'événement 'A ou B ou les deux se produisent'."
    },
    {
      question: "Quelle est la formule pour l'union de deux événements $A$ et $B$ ?",
      answer: "$P(A \\cup B) = P(A) + P(B) - P(A \\cap B)$"
    },
    {
      question: "Qu'est-ce que des événements incompatibles ?",
      answer: "Des événements sont incompatibles s'ils ne peuvent pas se produire ensemble : $P(A \\cap B) = 0$."
    },
    {
      question: "Qu'est-ce que des événements indépendants ?",
      answer: "Deux événements sont indépendants si la réalisation de l'un n'influence pas la probabilité de l'autre : $P_A(B) = P(B)$."
    },
    {
      question: "Comment calcule-t-on une probabilité conjointe si les événements sont indépendants ?",
      answer: "Si $A$ et $B$ sont indépendants, alors $P(A \\cap B) = P(A) \\times P(B)$."
    },
    {
      question: "Quelle est la formule de la probabilité conditionnelle de $B$ sachant $A$ ?",
      answer: "$P_A(B) = \\frac{P(A \\cap B)}{P(A)}$, si $P(A) \\ne 0$."
    },
    {
      question: "Quelle est la version conjointe de la formule des probabilités totales ?",
      answer: "Si $(B_i)$ forme une partition, alors:<div class='large-equation'>$P(A) = P(A \\cap B_1) + P(A \\cap B_2) + \\ldots + P(A \\cap B_n)$</div>"
    },
    {
      question: "Quelle est la version conditionnelle de la formule des probabilités totales ?",
      answer: "Si $(B_i)$ forme une partition, alors:<div class='large-equation'>$P(A) = P_{B_1}(A)P(B_1) + P_{B_2}(A)P(B_2) + \\ldots + P_{B_n}(A)P(B_n)$</div>"
    },
    {
      question: "Énonce le théorème de Bayes.",
      answer: "$P_B(A) = \\frac{P(A)P_A(B)}{P(B)} = \\frac{P(A \\cap B)}{P(B)}$"
    },
    {
      question: "Qu'est-ce qu'un tableau de contingence ?",
      answer: "C'est un tableau qui croise deux variables aléatoires pour représenter des probabilités conjointes et calculer les marginales et conditionnelles."
    },
    {
      question: "Comment calcule-t-on une probabilité conditionnelle à partir d'un tableau de contingence ?",
      answer: "En divisant une case par la somme de sa ligne ou colonne : $P_A(B) = \\frac{P(A \\cap B)}{P(A)}$"
    },
    {
      question: "Qu'est-ce qu'un arbre de probabilité ?",
      answer: "C'est une représentation graphique des différentes issues possibles d'une expérience aléatoire, avec les probabilités sur les branches."
    },
    {
      question: "Quelle est la règle pour calculer la probabilité d'un chemin dans un arbre ?",
      answer: "C'est le produit des probabilités le long du chemin."
    },
    {
      question: "Quelle est la loi de Bernoulli ?",
      answer: "Une variable $X \\sim \\mathcal{B}(p)$ prend 1 avec probabilité $p$ et 0 avec probabilité $1 - p$."
    },
    {
      question: "Quelle est l'espérance et la variance d'une Bernoulli $\\mathcal{B}(p)$ ?",
      answer: "$\\mathbb{E}(X) = p$, $\\text{Var}(X) = p(1 - p)$"
    },
    {
      question: "Quelle est la loi binomiale ?",
      answer: "$X \\sim \\mathcal{B}(n, p)$ modélise le nombre de succès dans $n$ répétitions indépendantes de Bernoulli."
    },
    {
      question: "Quelle est la formule de masse de la loi binomiale ?",
      answer: "$P(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi binomiale $\\mathcal{B}(n, p)$ ?",
      answer: "$\\mathbb{E}(X) = np$, $\\text{Var}(X) = np(1 - p)$"
    },
    {
      question: "Qu'est-ce que la loi de Poisson ?",
      answer: "Elle modélise un nombre d'événements rares dans un intervalle : $P(X = k) = \\frac{e^{-\\lambda} \\lambda^k}{k!}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi de Poisson $\\mathcal{P}(\\lambda)$ ?",
      answer: "$\\mathbb{E}(X) = \\lambda$, $\\text{Var}(X) = \\lambda$"
    },
    {
      question: "Qu'est-ce qu'une loi uniforme continue $\\mathcal{U}(a,b)$ ?",
      answer: "Une loi où toutes les valeurs entre $a$ et $b$ ont la même densité : $f(x) = \\frac{1}{b-a}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi uniforme $\\mathcal{U}(a,b)$ ?",
      answer: "$\\mathbb{E}(X) = \\frac{a + b}{2}$, $\\text{Var}(X) = \\frac{(b - a)^2}{12}$"
    },
    {
      question: "Quelle est la densité de la loi normale $\\mathcal{N}(\\mu, \\sigma^2)$ ?",
      answer: "$f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2} \\left( \\frac{x - \\mu}{\\sigma} \\right)^2}$"
    },
    {
      question: "Quelle est l'espérance et la variance d'une loi normale $\\mathcal{N}(\\mu, \\sigma^2)$ ?",
      answer: "$\\mathbb{E}(X) = \\mu$, $\\text{Var}(X) = \\sigma^2$"
    },
    {
      question: "Quand utilise-t-on le test du $\\chi^2$ ?",
      answer: "Pour tester si deux variables qualitatives sont indépendantes (dans un tableau de contingence)."
    },
    {
      question: "Quelle est la formule de la statistique $\\chi^2$ ?",
      answer: "$\\chi^2 = \\sum \\frac{(O_{ij} - E_{ij})^2}{E_{ij}}$"
    },
    {
      question: "Quelle est la formule des effectifs attendus pour un test $\\chi^2$ ?",
      answer: "$E_{ij} = \\frac{\\text{Total ligne}_i \\times \\text{Total colonne}_j}{\\text{Total général}}$"
    },
    {
      question: "Quelle est la statistique du test de Student ?",
      answer: "$t = \\frac{\\bar{x} - \\mu_0}{s / \\sqrt{n}}$"
    },
    {
      question: "Quand utilise-t-on le test de Student ?",
      answer: "Pour comparer la moyenne d'un échantillon à une moyenne théorique $\\mu_0$."
    },
    {
      question: "Bonus : Résoudre l'équation $i \\hbar \\frac{\\partial^\\alpha \\psi(x,t)}{\\partial t^\\alpha} + \\gamma \\left( \\frac{\\partial^2 \\psi}{\\partial x^2} - \\lambda |\\psi|^2 \\psi \\right) + \\int_0^t \\frac{e^{-(t-\\tau)^2}}{(t - \\tau)^{1-\\beta}} \\left( \\frac{\\delta \\mathcal{F}[\\psi]}{\\delta \\psi^*(x,\\tau)} \\right) d\\tau + \\mu \\sum_{n=1}^{\\infty} \\frac{(-1)^n}{n!} \\nabla^{2n} \\psi(x,t) = 0$",
      answer: "nan je rigole"
    }
  ];

  $(document).ready(function() {
    var currentCardIndex = 0;
    var animationInProgress = false;
    var navigationFailSafeTimer = null;
    
    // More reliable touch device detection
    const isTouchDevice = () => {
      return (('ontouchstart' in window) ||
          (navigator.maxTouchPoints > 0) ||
          (navigator.msMaxTouchPoints > 0) ||
          window.matchMedia('(hover: none) and (pointer: coarse)').matches);
    };
    
    const isTouch = isTouchDevice() || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Initialize carousel by creating all cards
    function initializeCarousel() {
      const carouselTrack = $('#carousel-track');
      const dotContainer = $('#carousel-dots');
      
      // Clear track
      carouselTrack.empty();
      dotContainer.empty();
      
      // Generate all flashcard elements
      flashcards.forEach((card, index) => {
        // Create flashcard container
        const cardContainer = $(`
          <div class="flashcard-container ${index === currentCardIndex ? 'active' : ''}">
            <div class="flashcard">
              <div class="card-face front">
                <div class="card-content">${card.question}</div>
                <div class="card-number">${index + 1} / ${flashcards.length}</div>
                <div class="card-hint">Cliquez pour voir la réponse</div>
                ${index === 0 ? '<div class="bounce-hint">↓</div>' : ''}
              </div>
              <div class="card-face back">
                <div class="card-content">${card.answer}</div>
                <div class="card-number">${index + 1} / ${flashcards.length}</div>
                <div class="card-hint">Cliquez pour voir la question</div>
              </div>
            </div>
          </div>
        `);
        
        // Append card to track
        carouselTrack.append(cardContainer);
      });
      
      // Create new navigation system
      createProgressNavigation();
      
      // Add click handler to flip cards
      $('.flashcard').on('click', function() {
        const cardIndex = $(this).closest('.flashcard-container').index();
        if (cardIndex === currentCardIndex) {
          flipCurrentCard();
        }
      });
      
      // Set appropriate relative positions for prev/active/next cards
      updateCardClasses();
      
      // Process MathJax for all cards at once
      if (window.MathJax) {
        MathJax.typesetPromise().then(() => {
          // Add indicators for overflowing equations
          checkAndAddScrollIndicators();
        }).catch((err) => console.log('MathJax error:', err));
      }

      // Remove bounce hint since we have persistent hints now
      $('.bounce-hint').remove();

      // Initialize arrow visibility immediately
      setTimeout(function() {
        updateArrowVisibility();
        console.log("Initial arrow visibility updated");
      }, 100); // Small delay to ensure DOM is ready
    }
    
    // Create new progress bar navigation
    function createProgressNavigation() {
      // Remove old dots if they exist
      $('.carousel-dots').hide();
      
      // Create new navigation container
      const navContainer = $('<div class="carousel-nav"></div>');
      const progressTrack = $('<div class="progress-track"></div>');
      const progressFill = $('<div class="progress-fill"></div>');
      const positionIndicator = $('<div class="position-indicator"></div>');
      
      // Set initial progress fill width
      const progressPercent = (currentCardIndex / (flashcards.length - 1)) * 100;
      progressFill.css('width', `${progressPercent}%`);
      
      // Set initial position indicator
      positionIndicator.text(`${currentCardIndex + 1} / ${flashcards.length}`);
      const positionPercent = (currentCardIndex / (flashcards.length - 1)) * 100;
      positionIndicator.css('left', `${positionPercent}%`);
      
      // Add progress track to container
      progressTrack.append(progressFill);
      navContainer.append(positionIndicator);
      navContainer.append(progressTrack);
      
      // Create markers for each card
      for (let i = 0; i < flashcards.length; i++) {
        const markerPosition = (i / (flashcards.length - 1)) * 100;
        const marker = $(`<div class="nav-marker ${i === currentCardIndex ? 'active' : ''}" data-index="${i}"></div>`);
        
        // Create tooltip for this marker
        const tooltip = $(`<div class="card-tooltip">${flashcards[i].question}</div>`);
        
        // Truncate long questions for tooltip
        const maxLength = 100;
        let tooltipText = flashcards[i].question;
        if (tooltipText.length > maxLength) {
          tooltipText = tooltipText.substring(0, maxLength) + '...';
        }
        // Strip HTML tags for tooltip
        tooltipText = tooltipText.replace(/<[^>]*>?/gm, '');
        tooltip.text(tooltipText);
        
        marker.append(tooltip);
        marker.css('left', `${markerPosition}%`);
        progressTrack.append(marker);
        
        // Add click handler for direct navigation
        marker.on('click', function() {
          const index = parseInt($(this).data('index'));
          if (!animationInProgress && index !== currentCardIndex) {
            goToCard(index);
          }
        });
      }
      
      // Add click handler to progress track for navigation
      progressTrack.on('click', function(e) {
        if (animationInProgress) return;
        
        // Get clicked position relative to track width
        const trackWidth = $(this).width();
        const clickOffset = e.offsetX;
        const clickPercent = clickOffset / trackWidth;
        
        // Calculate nearest card index
        const targetIndex = Math.round(clickPercent * (flashcards.length - 1));
        
        // Navigate to that card if not already there
        if (targetIndex !== currentCardIndex) {
          goToCard(targetIndex);
        }
      });
      
      // Add the navigation to the page
      $('.cards-carousel').after(navContainer);
    }
    
    // Update navigation when changing cards
    function updateNavigation() {
      // Update progress fill
      const progressPercent = (currentCardIndex / (flashcards.length - 1)) * 100;
      $('.progress-fill').css('width', `${progressPercent}%`);
      
      // Update active marker
      $('.nav-marker').removeClass('active');
      $(`.nav-marker[data-index="${currentCardIndex}"]`).addClass('active');
      
      // Update position indicator
      $('.position-indicator').text(`${currentCardIndex + 1} / ${flashcards.length}`);
      $('.position-indicator').css('left', `${progressPercent}%`);
    }
    
    // Update current card and adjacent card classes
    function updateCardClasses() {
      $('.flashcard-container').removeClass('active prev next');
      
      // Set active card
      $(`.flashcard-container:eq(${currentCardIndex})`).addClass('active');
      
      // Set previous card if available
      if (currentCardIndex > 0) {
        $(`.flashcard-container:eq(${currentCardIndex - 1})`).addClass('prev');
      }
      
      // Set next card if available
      if (currentCardIndex < flashcards.length - 1) {
        $(`.flashcard-container:eq(${currentCardIndex + 1})`).addClass('next');
      }
      
      // Update track position to center the current card
      updateTrackPosition();
      
      // Update dots
      $('.carousel-dot').removeClass('active');
      $(`.carousel-dot:eq(${currentCardIndex})`).addClass('active');

      // Also update progress navigation
      updateNavigation();
      
      // Update navigation arrow visibility based on current index
      updateArrowVisibility();
    }
    
    // Position the track to center the current card
    function updateTrackPosition() {
      const translateX = -100 * currentCardIndex;
      $('#carousel-track').css('transform', `translateX(${translateX}%)`);
    }
    
    // Go to a specific card with animation
    function goToCard(index) {
      if (animationInProgress) return;
      if (index < 0 || index >= flashcards.length) return;
      
      // Clear any existing fail-safe timer
      if (navigationFailSafeTimer) {
        clearTimeout(navigationFailSafeTimer);
      }
      
      animationInProgress = true;
      
      // Set a fail-safe timer to reset animation state if something goes wrong
      navigationFailSafeTimer = setTimeout(() => {
        console.log("Navigation fail-safe triggered");
        animationInProgress = false;
      }, 1500); // Longer than transition to ensure it only triggers if something goes wrong
      
      // Update current card index
      currentCardIndex = index;
      
      // Update card classes which handles the track position
      updateCardClasses();
      
      // Ensure card is showing front face
      $(`.flashcard-container:eq(${currentCardIndex})`).find('.flashcard').removeClass('flipped');
      
      // Update progress bar
      updateProgressBar();

      // Listen for transition end and reset animation flag
      const carouselTrack = document.getElementById('carousel-track');
      
      // Using both setTimeout and transitionend for redundancy
      const onTransitionComplete = function() {
        animationInProgress = false;
        if (navigationFailSafeTimer) {
          clearTimeout(navigationFailSafeTimer);
          navigationFailSafeTimer = null;
        }
        carouselTrack.removeEventListener('transitionend', onTransitionComplete);
      };
      
      carouselTrack.addEventListener('transitionend', onTransitionComplete, { once: true });
      
      // Backup timeout in case transitionend doesn't fire
      setTimeout(() => {
        animationInProgress = false;
        if (navigationFailSafeTimer) {
          clearTimeout(navigationFailSafeTimer);
          navigationFailSafeTimer = null;
        }
      }, 600); // Match the transition duration
    }
    
    // Flip the current card
    function flipCurrentCard() {
      if (animationInProgress) return;
      
      const currentCard = $(`.flashcard-container:eq(${currentCardIndex})`).find('.flashcard');
      const isFrontVisible = !currentCard.hasClass('flipped');
      
      // Flip the card
      if (isFrontVisible) {
        currentCard.addClass('flipped');
      } else {
        currentCard.removeClass('flipped');
      }
    }
    
    // Go to next card
    function nextCard() {
      if (currentCardIndex < flashcards.length - 1) {
        goToCard(currentCardIndex + 1);
      }
    }
    
    // Go to previous card
    function previousCard() {
      if (currentCardIndex > 0) {
        goToCard(currentCardIndex - 1);
      }
    }
    
    // Update progress bar - remove this function as we no longer have a progress bar
    function updateProgressBar() {
      // Progress bar was removed, so this function can be empty
      // We keep it to avoid breaking existing code that calls it
      updateNavigation();
    }
    
    // Highlight key animation
    function highlightKey(keyName) {
      // Find the key element with matching text content
      $(".key").each(function() {
        if ($(this).text() === keyName) {
          const key = $(this);
          // Add a highlight class
          key.css({
            "transform": "translateY(2px)",
            "opacity": "0.7"
          });
          
          // Remove it after animation completes
          setTimeout(function() {
            key.css({
              "transform": "",
              "opacity": ""
            });
          }, 200);
        }
      });
    }
    
    // Check for overflowing equations
    function checkAndAddScrollIndicators() {
      $('.card-content .MathJax_SVG_Display').each(function() {
        if (this.scrollWidth > this.clientWidth) {
          $(this).css('cursor', 'ew-resize');
        }
      });
    }
    
    // Initialize the carousel
    initializeCarousel();
    updateProgressBar();
    
    // Set up navigation arrow handlers with improved error handling
    $('#prev-arrow').on('click', function(e) {
      try {
        e.stopPropagation(); // Prevent event bubbling
        
        // Force navigation if stuck for too long
        if (animationInProgress && Date.now() - lastNavigationTime > 2000) {
          console.log("Forcing navigation - animation state was stuck");
          animationInProgress = false;
        }
        
        if (!animationInProgress) {
          lastNavigationTime = Date.now();
          previousCard();
          highlightKey("←");
        }
      } catch (err) {
        console.error("Error in prev button:", err);
        animationInProgress = false; // Reset on error
      }
    });
    
    $('#next-arrow').on('click', function(e) {
      try {
        e.stopPropagation(); // Prevent event bubbling
        
        // Force navigation if stuck for too long
        if (animationInProgress && Date.now() - lastNavigationTime > 2000) {
          console.log("Forcing navigation - animation state was stuck");
          animationInProgress = false;
        }
        
        if (!animationInProgress) {
          lastNavigationTime = Date.now();
          nextCard();
          highlightKey("→");
        }
      } catch (err) {
        console.error("Error in next button:", err);
        animationInProgress = false; // Reset on error
      }
    });
    
    // Add variable to track last navigation time
    var lastNavigationTime = Date.now();
    
    // Enhanced keyboard navigation with error recovery
    $(document).keydown(function(e) {
      try {
        // Force navigation if stuck for too long
        if (animationInProgress && Date.now() - lastNavigationTime > 2000) {
          console.log("Forcing navigation - animation state was stuck");
          animationInProgress = false;
        }
        
        if (animationInProgress) return;
        
        // Right arrow for next
        if (e.key === "ArrowRight") {
          lastNavigationTime = Date.now();
          nextCard();
          highlightKey("→");
        } 
        // Left arrow for previous
        else if (e.key === "ArrowLeft") {
          lastNavigationTime = Date.now();
          previousCard();
          highlightKey("←");
        } 
        // Space, Enter, ArrowUp or ArrowDown to flip
        else if (e.key === " " || e.key === "Space" || e.key === "Enter" || 
                e.key === "ArrowUp" || e.key === "ArrowDown") {
          flipCurrentCard();
          highlightKey("Espace");
          // Prevent page scroll on spacebar
          if (e.key === " " || e.key === "Space") {
            e.preventDefault();
          }
        }
      } catch (err) {
        console.error("Error in keyboard navigation:", err);
        animationInProgress = false; // Reset on error
      }
    });
    
    // Add touch swipe support - enhanced version
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let swipeThreshold = 30; // Lower threshold for more permissive detection
    let swipeDirectionDetermined = false;
    let isHorizontalSwipe = false;
    let activeSwipeDirection = null;
    
    // Add swipe direction indicators to the carousel
    $('.cards-carousel').append(`
      <div class="swipe-direction-indicator swipe-left-indicator">→</div>
      <div class="swipe-direction-indicator swipe-right-indicator">←</div>
    `);
    
    $('.cards-carousel')
      .on('touchstart', function(e) {
        try {
          // Force navigation if stuck for too long
          if (animationInProgress && Date.now() - lastNavigationTime > 2000) {
            console.log("Forcing navigation - animation state was stuck");
            animationInProgress = false;
          }
          
          if (animationInProgress) return;
          
          touchStartX = e.originalEvent.touches[0].clientX;
          touchStartY = e.originalEvent.touches[0].clientY;
          
          // Reset swipe detection state
          swipeDirectionDetermined = false;
          isHorizontalSwipe = false;
          activeSwipeDirection = null;
          
          // Add active state for touch feedback
          if (isTouch) {
            $(this).css('opacity', '0.98');
            // Mark track as being swiped for immediate visual feedback
            $('#carousel-track').addClass('swiping');
          }
          
          // Hide direction indicators initially
          $('.swipe-direction-indicator').removeClass('active');
        } catch (err) {
          console.error("Error in touchstart:", err);
          animationInProgress = false; // Reset on error
        }
      })
      .on('touchmove', function(e) {
        if (animationInProgress) return;
        
        const currentX = e.originalEvent.touches[0].clientX;
        const currentY = e.originalEvent.touches[0].clientY;
        const deltaX = currentX - touchStartX;
        const deltaY = Math.abs(currentY - touchStartY);
        
        // Determine swipe direction early if not yet determined
        if (!swipeDirectionDetermined) {
          // If we've moved enough to determine direction
          if (Math.abs(deltaX) > 10 || deltaY > 10) {
            isHorizontalSwipe = Math.abs(deltaX) > deltaY;
            swipeDirectionDetermined = true;
          }
        }
        
        // If it's a horizontal swipe, add enhanced visual feedback
        if (isHorizontalSwipe) {
          e.preventDefault(); // Prevent page scroll for horizontal swipes
          
          // Significant drag - show direction indicator
          if (Math.abs(deltaX) > 20) {
            if (deltaX > 0) {
              activeSwipeDirection = 'right';
              $('.swipe-right-indicator').addClass('active');
              $('.swipe-left-indicator').removeClass('active');
            } else {
              activeSwipeDirection = 'left';
              $('.swipe-left-indicator').addClass('active');
              $('.swipe-right-indicator').removeClass('active');
            }
          } else {
            // Reset indicators if swipe isn't significant yet
            activeSwipeDirection = null;
            $('.swipe-direction-indicator').removeClass('active');
          }
          
          // Apply drag effect to track - more responsive with larger multiplier
          const trackTransform = -100 * currentCardIndex + (deltaX * 0.3);
          $('#carousel-track').css('transform', `translateX(${trackTransform}%)`);
          
          // Also adjust opacity of adjacent cards based on swipe direction
          if (deltaX > 0 && currentCardIndex > 0) {
            // Swiping right, highlight previous card
            $(`.flashcard-container:eq(${currentCardIndex-1})`).css('opacity', 0.6 + (deltaX * 0.002));
            if (currentCardIndex < flashcards.length - 1) {
              $(`.flashcard-container:eq(${currentCardIndex+1})`).css('opacity', 0.6 - (deltaX * 0.001));
            }
          } else if (deltaX < 0 && currentCardIndex < flashcards.length - 1) {
            // Swiping left, highlight next card
            $(`.flashcard-container:eq(${currentCardIndex+1})`).css('opacity', 0.6 + (Math.abs(deltaX) * 0.002));
            if (currentCardIndex > 0) {
              $(`.flashcard-container:eq(${currentCardIndex-1})`).css('opacity', 0.6 - (Math.abs(deltaX) * 0.001));
            }
          }
        }
      })
      .on('touchend', function(e) {
        if (animationInProgress) return;
        
        // Reset opacity and remove swiping class
        $(this).css('opacity', '');
        $('#carousel-track').removeClass('swiping');
        
        // Hide direction indicators
        $('.swipe-direction-indicator').removeClass('active');
        
        // Reset adjacent cards opacity
        $('.flashcard-container').css('opacity', '');
        
        touchEndX = e.originalEvent.changedTouches[0].clientX;
        touchEndY = e.originalEvent.changedTouches[0].clientY;
        
        // Calculate swipe distance
        const swipeDistanceX = touchEndX - touchStartX;
        const swipeDistanceY = Math.abs(touchEndY - touchStartY);
        
        // More permissive criteria for horizontal swipes:
        // 1. If we already determined it's a horizontal swipe
        // 2. If the horizontal distance exceeds the threshold and is greater than vertical
        if (isHorizontalSwipe && Math.abs(swipeDistanceX) > swipeThreshold) {
          // Add fast transition class to all cards for snappier response
          $('.flashcard-container').addClass('fast-transition');
          
          if (swipeDistanceX > 0) {
            // Swipe right - go to previous card
            previousCard();
          } else {
            // Swipe left - go to next card
            nextCard();
          }
          
          // Remove fast transition class after animation completes
          setTimeout(() => {
            $('.flashcard-container').removeClass('fast-transition');
          }, 300);
        } else {
          // Reset position if swipe wasn't valid
          updateTrackPosition();
        }
        
        // Reset swipe direction
        activeSwipeDirection = null;
      })
      .on('touchcancel', function() {
        // Reset everything on touch cancel
        updateTrackPosition();
        $(this).css('opacity', '');
        $('#carousel-track').removeClass('swiping');
        $('.swipe-direction-indicator').removeClass('active');
        $('.flashcard-container').css('opacity', '');
      });

    // Handle orientation change to optimize layout
    window.addEventListener('orientationchange', function() {
      // Wait for orientation change to complete
      setTimeout(function() {
        updateTrackPosition();
      }, 300);
    });
    
    // ...rest of your existing code...
    // Add CSS for new mobile top hints
    $('head').append(`
      <style>
        .mobile-top-hints {
          display: none; /* Hidden by default, only shown on mobile */
          margin: -5px auto 25px;
          text-align: center;
          font-family: NeueHaas;
          font-size: 13px;
        }
        
        .top-tap-hint, .top-swipe-hint {
          display: inline-block;
          margin: 0 10px;
          opacity: 0.8;
        }
        
        body.day .mobile-top-hints {
          color: #403E43;
        }
        
        body.night .mobile-top-hints {
          color: #C8C8C9;
        }
        
        /* Only show on touch devices */
        @media (hover: none) and (pointer: coarse) {
          .mobile-top-hints {
            display: block;
          }
          
          /* Hide the bottom mobile hints since we now show them at the top */
          .mobile-hints {
            display: none;
          }
        }
      </style>
    `);
    
    // Function to manually reset animation state - can be called by user
    window.resetFlashcardsNavigation = function() {
      console.log("Manual navigation reset triggered");
      animationInProgress = false;
      if (navigationFailSafeTimer) {
        clearTimeout(navigationFailSafeTimer);
        navigationFailSafeTimer = null;
      }
      // Reset the carousel to current position
      updateTrackPosition();
      updateCardClasses();
    };
    
    // Add a double-click handler on the body to reset navigation if needed
    $('body').on('dblclick', function() {
      if (animationInProgress) {
        resetFlashcardsNavigation();
      }
    });
    
    // Add automatic periodic check for stuck animation state
    setInterval(function() {
      if (animationInProgress && Date.now() - lastNavigationTime > 3000) {
        console.log("Auto-recovery: Animation state stuck for too long");
        resetFlashcardsNavigation();
      }
    }, 3000);

    // Function to update the visibility of navigation arrows - improved version
    function updateArrowVisibility() {
      console.log("Updating arrow visibility. Current card index:", currentCardIndex);
      
      // Hide left arrow on first card
      if (currentCardIndex === 0) {
        console.log("Hiding prev arrow");
        $('#prev-arrow').addClass('hidden');
        // Use visibility instead of display to preserve layout
        $('#prev-arrow').css({
          'opacity': '0',
          'visibility': 'hidden',
          'pointer-events': 'none'
          // Don't hide with display:none as it shifts layout
        });
      } else {
        console.log("Showing prev arrow");
        $('#prev-arrow').removeClass('hidden');
        $('#prev-arrow').css({
          'opacity': '',
          'visibility': '',
          'pointer-events': ''
        });
      }
      
      // Hide right arrow on last card
      if (currentCardIndex === flashcards.length - 1) {
        console.log("Hiding next arrow");
        $('#next-arrow').addClass('hidden');
        $('#next-arrow').css({
          'opacity': '0',
          'visibility': 'hidden',
          'pointer-events': 'none'
          // Don't hide with display:none as it shifts layout
        });
      } else {
        console.log("Showing next arrow");
        $('#next-arrow').removeClass('hidden');
        $('#next-arrow').css({
          'opacity': '',
          'visibility': '',
          'pointer-events': ''
        });
      }
    }

    // After page is loaded, ensure arrows are properly hidden/shown
    $(document).ready(function() {
      // Make sure arrows visibility is checked after everything is loaded
      setTimeout(function() {
        updateArrowVisibility();
        console.log("Document ready arrow visibility updated");
      }, 500);
    });

    // Function to update the visibility of navigation arrows
    function updateArrowVisibility() {
      // Hide left arrow on first card
      if (currentCardIndex === 0) {
        $('#prev-arrow').addClass('hidden');
      } else {
        $('#prev-arrow').removeClass('hidden');
      }
      
      // Hide right arrow on last card
      if (currentCardIndex === flashcards.length - 1) {
        $('#next-arrow').addClass('hidden');
      } else {
        $('#next-arrow').removeClass('hidden');
      }
    }
  });
  </script>
</body>
</html>