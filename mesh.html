<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BERXY0M3FY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BERXY0M3FY');
  </script>

  <!-- Basic Page Needs -->
  <meta charset="utf-8">
  <title>3D Mesh Visualizer - Hadrien Bigo-Balland</title>
  <meta name="description" content="Visualisation de landmarks sur un mesh 3D">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/animate.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/dot.png">

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <style>
    /* Fix for horizontal scrolling issue */
    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      position: relative;
    }
    
    body.day {
      background-color: #f9f9fa;
      color: #403E43;
    }
    
    body.night {
      background-color: #1c1c1f;
      color: #C8C8C9;
    }
    
    /* Header container */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: transparent;
      pointer-events: none;
    }
    
    .back-info-container {
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
    }

    .header {
      display: flex;
      align-items: center;
      margin: 0;
      pointer-events: auto;
    }
    
    /* Theme toggle */
    .theme-toggle {
      display: flex;
      align-items: center;
      pointer-events: auto;
    }

    body.night #moon {
      display: none;
    }

    body.day #moon {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.night #sun {
      display: block;
      cursor: pointer;
      width: 20px;
    }

    body.day #sun {
      display: none;
    }
    
    /* Enhanced back button styling with elegant glow effect */
    .back-link {
      text-decoration: none;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
      background-color: transparent;
      padding: 0;
      margin: 0;
      line-height: 1;
      position: relative;
      overflow: hidden;
    }

    .back-link:before {
      content: "‚Üê";
      transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
      font-size: 18px;
      z-index: 2;
      position: relative;
    }

    /* Subtle background glow effect */
    .back-link:after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      opacity: 0;
      transition: opacity 0.4s ease;
      border-radius: 50%;
      z-index: 1;
    }

    body.day .back-link {
      color: #403E43;
      border: 1px solid rgba(0, 0, 0, 0.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    body.night .back-link {
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    body.day .back-link:hover {
      border-color: rgba(0, 0, 0, 0.3);
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    body.night .back-link:hover {
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
      transform: translateY(-1px);
    }

    .back-link:hover:before {
      transform: translateX(-2px);
    }

    .back-link:hover:after {
      opacity: 0.2;
    }

    body.night .back-link:after {
      background: radial-gradient(circle, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 70%);
    }

    /* Title */
    .title {
      margin: 0;
      font-family: NeueHaasMedium;
      font-size: 20px;
      letter-spacing: .25px;
      line-height: 28px;
      padding-left: 15px;
    }
    
    /* Canvas */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    /* Tooltip styles */
    .tooltip {
      position: absolute;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: NeueHaas, Arial, sans-serif;
      font-size: 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 999;
      white-space: nowrap;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    body.day .tooltip {
      background-color: rgba(255, 255, 255, 0.9);
      color: #403E43;
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    
    body.night .tooltip {
      background-color: rgba(45, 45, 50, 0.9);
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    /* Controls hint */
    .controls-hint {
      position: fixed;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px 15px;
      border-radius: 8px;
      font-family: NeueHaas, Arial, sans-serif;
      font-size: 14px;
      text-align: center;
      z-index: 100;
      transition: all 0.3s ease;
    }
    
    body.day .controls-hint {
      background-color: rgba(255, 255, 255, 0.8);
      color: #403E43;
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    body.night .controls-hint {
      background-color: rgba(45, 45, 50, 0.8);
      color: #C8C8C9;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .controls-hint-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }
    
    .hint-item {
      display: flex;
      align-items: center;
    }
    
    .hint-icon {
      font-size: 16px;
      margin-right: 6px;
    }
  </style>
  
  <!-- Script for day/night theme management -->
  <script>
  $(document).ready(function(){
      // Event handlers for day/night buttons
      $("#moon").click(function(){
          $("body").removeClass("day");
          $("body").addClass("night");
          localStorage.setItem('theme', 'night');
          updateSceneBackground();
      });
      
      $("#sun").click(function(){
          $("body").removeClass("night");
          $("body").addClass("day");
          localStorage.setItem('theme', 'day');
          updateSceneBackground();
      });
      
      // Apply stored theme
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme) {
          if (storedTheme === 'night') {
              $("body").removeClass("day");
              $("body").addClass("night");
          } else {
              $("body").addClass("day");
              $("body").removeClass("night");
          }
      } else {
          // Default theme
          $("body").addClass("day");
      }
      
      // Call updateSceneBackground after the Three.js scene is initialized
      // Use a small timeout to ensure the Three.js script has had time to run
      setTimeout(function() {
          if (typeof updateThreeBackground === 'function') {
              updateThreeBackground();
          }
      }, 100);
  });

  function updateSceneBackground() {
      // This function will be defined in the Three.js script
      // It will be called when the theme changes
      if (typeof updateThreeBackground === 'function') {
          updateThreeBackground();
      }
  }
  </script>
</head>
<body>
  <!-- Header -->
  <div class="header-container">
    <div class="back-info-container">
      <a href="index.html" class="back-link"></a>
      <h1 class="title">Visualisation 3D Mesh</h1>
    </div>
    <div class="theme-toggle">
      <img src="images/sun.svg" id="moon">
      <img src="images/moon.svg" id="sun">
    </div>
  </div>
  
  <!-- Tooltip div -->
  <div class="tooltip" id="tooltip"></div>
  
  <!-- Controls hint -->
  <div class="controls-hint">
    <div class="controls-hint-content">
      <div class="hint-item"><span class="hint-icon">üñ±Ô∏è</span> Cliquer + d√©placer pour faire tourner</div>
      <div class="hint-item"><span class="hint-icon">‚öôÔ∏è</span> Molette pour zoomer</div>
    </div>
  </div>
  
  <!-- Three.js scripts -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/PLYLoader.js"></script>
  
  <script>
      // Initialize the scene
      const scene = new THREE.Scene();
      
      // Create updateThreeBackground function before it might be called
      function updateThreeBackground() {
          const isNightMode = document.body.classList.contains('night');
          if (isNightMode) {
              scene.background = new THREE.Color(0x1a1a1d); // Dark theme background
          } else {
              scene.background = new THREE.Color(0xf5f5f7); // Light theme background
          }
      }
      
      // Initial background color - immediately set based on current theme
      updateThreeBackground();
      
      // Initialize the camera
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.z = 1500;
      
      // Initialize the renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.sortObjects = true;
      document.body.appendChild(renderer.domElement);
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      // Orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      let meshCenter = null;
      let meshLoaded = false;
      let meshSize = new THREE.Vector3();
      let landmarksToLoad = 6;
      let landmarksLoaded = 0;
      const loadedLandmarkSpheres = [];
      
      // Add raycaster and mouse variables
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const tooltipElement = document.getElementById('tooltip');
      let intersectedObject = null;
      let mouseX = 0, mouseY = 0; // Store actual mouse coordinates

      // Define landmarks
      const landmarks = [
          { file: 'landmark_wrist.ply', color: 0xff0000, name: 'Poignet' },
          { file: 'landmark_armpit.ply', color: 0x00ff00, name: 'Aisselle' },
          { file: 'landmark_biceps.ply', color: 0x0000ff, name: 'Biceps' },
          { file: 'landmark_elbow.ply', color: 0xffff00, name: 'Coude' },
          { file: 'landmark_intermediate_forearm.ply', color: 0x800080, name: 'Avant-bras interm√©diaire' },
          { file: 'landmark_maximum_forearm.ply', color: 0xff8000, name: 'Avant-bras maximum' }
      ];

      function checkAllLoaded() {
          if (meshLoaded && landmarksLoaded === landmarksToLoad) {
              // Adjust camera and controls
              const maxDim = Math.max(meshSize.x, meshSize.y, meshSize.z);
              camera.position.z = maxDim * 1.5;
              controls.target.set(0, 0, 0);
              controls.update();

              // Now reposition landmarks relative to mesh center
              loadedLandmarkSpheres.forEach(sphereGroup => {
                  sphereGroup.position.x = -meshCenter.x;
                  sphereGroup.position.y = -meshCenter.y;
                  sphereGroup.position.z = -meshCenter.z;
              });
          }
      }

      // Load mesh
      const objLoader = new THREE.OBJLoader();
      objLoader.load(
          'mesh_arm.obj',
          function (object) {
              const boundingBox = new THREE.Box3().setFromObject(object);
              meshCenter = boundingBox.getCenter(new THREE.Vector3());
              meshSize = boundingBox.getSize(new THREE.Vector3());

              object.traverse(function(child) {
                  if (child instanceof THREE.Mesh) {
                      // Create a material that works in both light and dark themes
                      const isNightMode = document.body.classList.contains('night');
                      const meshColor = isNightMode ? 0x88aacc : 0x88ccff;
                      
                      child.material = new THREE.MeshPhongMaterial({
                          color: meshColor,
                          transparent: true,
                          opacity: 0.4,
                          side: THREE.DoubleSide
                      });
                      // Make sure mesh doesn't interfere with raycasting to landmarks
                      child.renderOrder = 0; // Lower render order for mesh
                  }
              });

              // Reposition mesh to center it
              object.position.sub(meshCenter);

              scene.add(object);
              meshLoaded = true;
              checkAllLoaded();
          },
          function (xhr) {
              console.log('Mesh: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
          },
          function (error) {
              console.error('Error loading the mesh:', error);
          }
      );

      // Load landmarks
      const plyLoader = new THREE.PLYLoader();
      landmarks.forEach(function(landmark) {
          plyLoader.load(
              landmark.file,
              function (geometry) {
                  const sphereRadius = 5; // Size of the sphere
                  const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                  const material = new THREE.MeshPhongMaterial({ 
                      color: landmark.color,
                      shininess: 80,
                      transparent: false, // Make sure landmarks aren't transparent
                      depthTest: true,    // Ensure proper depth testing
                      renderOrder: 1      // Higher render order for landmarks
                  });

                  // Create a group to hold all spheres for this landmark
                  const sphereGroup = new THREE.Group();
                  
                  // Get vertices from the loaded PLY geometry
                  const positions = geometry.getAttribute('position').array;
                  
                  // Create a sphere for each vertex in the PLY file
                  for (let i = 0; i < positions.length; i += 3) {
                      const x = positions[i];
                      const y = positions[i + 1];
                      const z = positions[i + 2];
                      
                      const sphere = new THREE.Mesh(sphereGeometry, material);
                      sphere.position.set(x, y, z);
                      
                      // Add custom properties for tooltips
                      sphere.userData = {
                          landmarkName: landmark.name,
                          originalPosition: new THREE.Vector3(x, y, z)
                      };
                      
                      sphereGroup.add(sphere);
                  }
                  
                  scene.add(sphereGroup);
                  loadedLandmarkSpheres.push(sphereGroup);

                  landmarksLoaded++;
                  checkAllLoaded();
              },
              function (xhr) {
                  console.log(landmark.file + ': ' + (xhr.loaded / xhr.total * 100) + '% loaded');
              },
              function (error) {
                  console.error('Error loading ' + landmark.file + ':', error);
                  landmarksLoaded++;
                  checkAllLoaded();
              }
          );
      });

      // Handle mouse move for tooltips
      function onMouseMove(event) {
          event.preventDefault();

          // Store actual mouse coordinates for tooltip positioning
          mouseX = event.clientX;
          mouseY = event.clientY;
          
          // Calculate mouse position in normalized device coordinates
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      }

      // Update the tooltip position and content
      function updateTooltip() {
          // Update the picking ray with the camera and mouse position
          raycaster.setFromCamera(mouse, camera);

          // Get all objects that can be intersected
          const intersectableObjects = [];
          loadedLandmarkSpheres.forEach(group => {
              group.children.forEach(sphere => {
                  intersectableObjects.push(sphere);
              });
          });

          // Calculate objects intersecting the picking ray
          const intersects = raycaster.intersectObjects(intersectableObjects, true);

          // Hide tooltip by default
          tooltipElement.style.opacity = 0;
          
          if (intersects.length > 0) {
              // We have an intersection - show tooltip
              const intersected = intersects[0].object;
              const userData = intersected.userData;
              
              // Position the tooltip near the mouse cursor using stored coordinates
              tooltipElement.style.left = (mouseX + 15) + 'px';
              tooltipElement.style.top = mouseY + 'px';
              
              // Format position to 2 decimal places
              const worldPos = new THREE.Vector3();
              worldPos.copy(intersected.position);
              
              // Get world position by applying parent transformations
              intersected.getWorldPosition(worldPos);
              
              const formattedPos = `(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)})`;
              
              // Set tooltip content
              tooltipElement.innerHTML = `<strong>${userData.landmarkName}</strong><br>Position: ${formattedPos}`;
              
              // Show tooltip
              tooltipElement.style.opacity = 1;
              
              document.body.style.cursor = 'pointer';
              intersectedObject = intersected;
          } else {
              document.body.style.cursor = 'auto';
              intersectedObject = null;
          }
      }

      // Add event listeners
      window.addEventListener('mousemove', onMouseMove, false);
      
      // Handle window resize
      window.addEventListener('resize', function () {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      function animate() {
          requestAnimationFrame(animate);
          controls.update();
          updateTooltip(); // Update tooltip on each frame
          renderer.render(scene, camera);
      }
      animate();
      
      // Hide controls hint after a while
      setTimeout(() => {
          document.querySelector('.controls-hint').style.opacity = '0.7';
      }, 5000);
  </script>
</body>
</html>