<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Théorème Central Limite - Illustration</title>
  <meta name="description" content="Illustration interactive du théorème central limite avec des lancers de pièce">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/animate.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/dot.png">

  <!-- D3.js pour les visualisations -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <!-- jQuery pour la gestion du thème jour/nuit -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
  
  <!-- MathJax pour les formules mathématiques -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <!-- Script pour la gestion du thème jour/nuit -->
  <script>
  $(document).ready(function(){
      // Gestionnaires d'événements pour les boutons jour/nuit
      $("#moon").click(function(){
          $("body").addClass("day");
          $("body").removeClass("night");
          localStorage.setItem('theme', 'day');
          updateVisualization(); // Rafraîchir la visualisation pour appliquer le nouveau thème
      });
      $("#sun").click(function(){
          $("body").removeClass("day");
          $("body").addClass("night");
          localStorage.setItem('theme', 'night');
          updateVisualization(); // Rafraîchir la visualisation pour appliquer le nouveau thème
      });
      
      // Appliquer le thème enregistré
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme) {
          if (storedTheme === 'night') {
              $("body").removeClass("day");
              $("body").addClass("night");
          } else {
              $("body").addClass("day");
              $("body").removeClass("night");
          }
      }
  });
  </script>
  <style>
    /* Styles spécifiques à cette page */
    .visualization-single {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .visualization-container {
      width: 100%;
      height: 300px;
      overflow: hidden;
      margin: 0 auto;
      position: relative;
      border-radius: 8px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }
    
    body.night .visualization-container {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .controls-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
      padding: 24px;
      border-radius: 12px;
      background-color: rgba(74, 137, 220, 0.03);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.02);
      transition: all 0.3s ease;
    }

    .controls-panel:hover {
      background-color: rgba(74, 137, 220, 0.05);
    }

    body.night .controls-panel {
      background-color: rgba(93, 156, 250, 0.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    body.night .controls-panel:hover {
      background-color: rgba(93, 156, 250, 0.08);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
      flex: 1;
      position: relative;
    }

    .control-group label {
      font-family: NeueHaasMedium;
      font-size: 15px;
      margin-bottom: 12px;
      color: #403E43;
      transition: color 0.3s ease;
    }

    body.night .control-group label {
      color: #C8C8C9;
    }
    
    .slider-container {
      position: relative;
      width: 100%;
      padding: 10px 0;
      margin-top: 5px;
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 8px;
      outline: none;
      background: linear-gradient(90deg, #4a89dc 0%, #73a7f5 100%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }

    body.night input[type="range"] {
      background: linear-gradient(90deg, #5d9cfa 0%, #84b6ff 100%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]:hover {
      height: 6px;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: 2px solid #4a89dc;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      position: relative;
    }

    body.night input[type="range"]::-webkit-slider-thumb {
      background: #333333;
      border-color: #5d9cfa;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
    }

    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(1.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: 2px solid #4a89dc;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    body.night input[type="range"]::-moz-range-thumb {
      background: #333333;
      border-color: #5d9cfa;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.15);
    }

    input[type="range"]::-moz-range-progress {
      background-color: #4a89dc;
      height: 4px;
      border-radius: 8px;
    }

    body.night input[type="range"]::-moz-range-progress {
      background-color: #5d9cfa;
    }
    
    /* Sample size value and input - make it more elegant */
    .sample-size-display {
      display: flex;
      align-items: center;
      margin-top: 4px;
    }
    
    #sample-size-value {
      font-weight: bold;
      color: #4a89dc;
      transition: all 0.3s ease;
      display: none; /* Hide the old display span */
    }
    
    #sample-size-input {
      width: 70px;
      padding: 6px 10px;
      border: 2px solid rgba(74, 137, 220, 0.3);
      border-radius: 6px;
      font-family: NeueHaasMedium;
      font-size: 15px;
      font-weight: bold;
      color: #4a89dc;
      background: rgba(74, 137, 220, 0.05);
      text-align: center;
      transition: all 0.3s ease;
      margin-left: 10px;
    }
    
    #sample-size-input:focus {
      outline: none;
      border-color: #4a89dc;
      background: rgba(74, 137, 220, 0.1);
      box-shadow: 0 0 0 3px rgba(74, 137, 220, 0.2);
    }
    
    body.night #sample-size-value {
      color: #5d9cfa;
    }
    
    body.night #sample-size-input {
      color: #5d9cfa;
      border-color: rgba(93, 156, 250, 0.3);
      background: rgba(93, 156, 250, 0.08);
    }
    
    body.night #sample-size-input:focus {
      border-color: #5d9cfa;
      background: rgba(93, 156, 250, 0.15);
      box-shadow: 0 0 0 3px rgba(93, 156, 250, 0.2);
    }
    
    @media (max-width: 768px) {
      #sample-size-input {
        width: 60px;
        padding: 5px 8px;
        font-size: 14px;
      }
    }
    
    .visualization-card {
      padding: 24px;
      border-radius: 16px;
      background-color: white;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
      transition: all 0.3s ease;
      border: 1px solid rgba(0, 0, 0, 0.03);
    }

    .visualization-card:hover {
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      transform: translateY(-2px);
    }

    body.night .visualization-card {
      background-color: rgba(45, 45, 50, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.03);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    body.night .visualization-card:hover {
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    .visualization-card h3 {
      font-family: NeueHaasMedium;
      font-size: 18px;
      margin-bottom: 20px;
      text-align: center;
      position: relative;
      color: #403E43;
    }

    body.night .visualization-card h3 {
      color: #C8C8C9;
    }

    .visualization-card h3:after {
      content: '';
      position: absolute;
      width: 40px;
      height: 2px;
      background: #4a89dc;
      bottom: -8px;
      left: 50%;
      margin-left: -20px;
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    body.night .visualization-card h3:after {
      background: #5d9cfa;
    }

    .visualization-card:hover h3:after {
      width: 60px;
      margin-left: -30px;
    }
    
    .back-button {
      display: inline-flex;
      align-items: center;
      margin-bottom: 30px;
      padding: 10px 16px;
      background-color: transparent;
      border: none;
      border-radius: 30px;
      font-family: NeueHaas;
      font-size: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .back-button:before {
      content: "←";
      margin-right: 8px;
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
    }
    
    .back-button:after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(74, 137, 220, 0.08);
      border-radius: 30px;
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
      z-index: 0;
    }
    
    body.night .back-button:after {
      background-color: rgba(93, 156, 250, 0.1);
    }
    
    .back-button:hover:after {
      transform: scaleX(1);
    }
    
    .back-button:hover:before {
      transform: translateX(-3px);
    }
    
    .stat-display {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
      gap: 20px;
    }
    
    .stat-item {
      text-align: center;
      padding: 12px;
      border-radius: 8px;
      background-color: rgba(74, 137, 220, 0.04);
      flex: 1;
      transition: all 0.3s ease;
    }
    
    body.night .stat-item {
      background-color: rgba(93, 156, 250, 0.08);
    }
    
    .stat-item:hover {
      background-color: rgba(74, 137, 220, 0.08);
      transform: translateY(-2px);
    }
    
    body.night .stat-item:hover {
      background-color: rgba(93, 156, 250, 0.12);
    }
    
    .stat-label {
      font-family: NeueHaasMedium;
      font-size: 12px;
      display: block;
      margin-bottom: 6px;
      color: #8A898C;
    }
    
    body.night .stat-label {
      color: #A8A8A9;
    }
    
    .stat-value {
      font-family: NeueHaasMedium;
      font-size: 20px;
      color: #4a89dc;
      transition: all 0.3s ease;
    }
    
    body.night .stat-value {
      color: #5d9cfa;
    }
    
    .description {
      font-size: 15px;
      line-height: 1.6;
      margin: 20px 0;
      color: #6A6875;
      padding: 0 5px;
    }
    
    body.night .description {
      color: #A8A8A9;
    }
    
    /* Improved tooltip */
    .tooltip {
      position: absolute;
      padding: 10px 14px;
      background: rgba(255, 255, 255, 0.97);
      color: #333;
      border-radius: 8px;
      pointer-events: none;
      font-family: NeueHaas;
      font-size: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.12);
      max-width: 200px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: opacity 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      transform-origin: top center;
      opacity: 0;
      transform: translateY(5px) scale(0.98);
      z-index: 1000;
    }
    
    body.night .tooltip {
      background: rgba(45, 45, 50, 0.95);
      color: #fff;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .tooltip.visible {
      transform: translateY(0) scale(1);
      opacity: 1;
    }
    
    .tooltip strong {
      color: #4a89dc;
      font-family: NeueHaasMedium;
    }
    
    body.night .tooltip strong {
      color: #5d9cfa;
    }
    
    /* Ajustements pour mobile */
    @media (max-width: 768px) {
      .visualization-container {
        height: 260px; /* Slightly taller for mobile */
        border-radius: 12px;
        margin-top: 5px;
      }
      
      .clt-container {
        padding: 15px 10px;
      }
      
      .clt-header h1 {
        font-size: 24px;
        padding-bottom: 15px;
        line-height: 1.3;
      }
      
      .clt-header p {
        font-size: 15px;
        line-height: 1.5;
        padding: 0 5px;
      }
      
      .info-panel {
        padding: 16px;
        font-size: 14px;
        border-radius: 12px;
        margin: 20px 5px;
      }
      
      .info-panel p {
        margin-bottom: 10px;
      }
      
      .controls-panel {
        padding: 20px;
        margin: 20px 5px 25px;
        border-radius: 12px;
      }
      
      .visualization-card {
        padding: 18px;
        border-radius: 12px;
        margin: 0 5px;
      }
      
      .visualization-card h3 {
        font-size: 17px;
        margin-bottom: 18px;
      }
      
      .description {
        font-size: 14px;
        margin: 15px 0;
        line-height: 1.5;
      }
      
      .control-group label {
        font-size: 15px;
        padding-bottom: 5px;
      }
      
      .stat-display {
        flex-direction: row; /* Keep it row on mobile for better layout */
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
      }
      
      .stat-item {
        min-width: 110px; /* Ensure they don't get too squished */
        padding: 10px;
      }
      
      .stat-label {
        font-size: 11px;
      }
      
      .stat-value {
        font-size: 18px;
      }
      
      /* Improved touch experience */
      input[type="range"] {
        height: 6px; /* Thicker track for easier touch */
        margin: 8px 0;
      }
      
      input[type="range"]::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
        border-width: 2px;
      }
      
      input[type="range"]::-moz-range-thumb {
        width: 24px;
        height: 24px;
      }
      
      .tooltip {
        padding: 12px 16px;
        font-size: 13px;
        max-width: 220px;
      }
      
      .back-button {
        font-size: 14px;
        padding: 10px 15px;
        margin-bottom: 20px;
      }
    }
    
    /* Enhanced touch-specific styles */
    @media (hover: none) {
      .histogram-rect {
        cursor: pointer;
      }
      
      input[type="range"]::-webkit-slider-thumb {
        transform: scale(1.1);
        width: 26px;
        height: 26px;
      }
      
      input[type="range"]::-moz-range-thumb {
        transform: scale(1.1);
        width: 26px;
        height: 26px;
      }
      
      .stat-item:active {
        background-color: rgba(74, 137, 220, 0.1);
      }
      
      body.night .stat-item:active {
        background-color: rgba(93, 156, 250, 0.15);
      }
      
      /* Make back button more touchable */
      .back-button {
        padding: 12px 18px;
      }
    }
    
    .stat-display {
      display: flex;
      justify-content: space-around;
      margin-top: 15px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-label {
      font-family: NeueHaasMedium;
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-family: NeueHaasMedium;
      font-size: 18px;
      color: #4a89dc;
    }
    
    body.night .stat-value {
      color: #5d9cfa;
    }
    
    .axis-label {
      font-family: NeueHaas;
      font-size: 11px;
      fill: #8A898C;
    }
    
    body.night .axis-label {
      fill: #C8C8C9;
    }
    
    .normal-curve {
      stroke: #ff6b6b;
      stroke-width: 2;
      stroke-dasharray: 5,3;
      fill: none;
    }
    
    body.night .normal-curve {
      stroke: #ff8787;
    }
    
    /* Amélioration du contraste pour la lisibilité */
    .axis text {
      font-weight: medium;
    }
    
    /* Fix pour Safari/iOS */
    svg {
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Styles pour les boutons jour/nuit qui correspondent à ceux de la page d'accueil */
    .three.columns.icon {
      text-align: right;
      margin-bottom: 20px;
    }
    
    body.night #moon {
      cursor: pointer;
      width: 20px;
      position: relative;
      top: 0px;
      display: inline-block;
    }

    body.day #moon {
      display: none;
    }

    body.night #sun {
      display: none;
    }

    body.day #sun {
      cursor: pointer;
      width: 20px;
      position: relative;
      top: 0px;
      display: inline-block;
    }
    
    @media (max-width: 550px) {
      body.night #moon {
        margin-bottom: 20px;
        padding-right: 8px;
        width: 20px;
        float: right;
      }

      body.day #sun {
        margin-bottom: 20px;
        padding-right: 8px;
        width: 20px;
        float: right;
      }
    }
    
    /* Coin flip animation styles */
    .coin-animation-container {
      height: 220px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 30px auto 70px; /* Increased bottom margin from 40px to 70px */
      perspective: 1000px;
      position: relative;
    }
    
    .coin {
      position: relative;
      width: 150px;
      height: 150px;
      transform-style: preserve-3d;
      transition: transform 0.05s ease;
      cursor: default;
    }
    
    .coin-face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: NeueHaasMedium;
      font-size: 28px;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
    }
    
    .coin-heads {
      background: linear-gradient(45deg, #c0c0c0, #e0e0e0, #c0c0c0);
      border: 8px solid #b0b0b0;
      color: #555;
    }
    
    .coin-tails {
      background: linear-gradient(45deg, #d4af37, #f9d775, #d4af37);
      border: 8px solid #c4a02f;
      color: #885e00;
      transform: rotateY(180deg);
    }
    
    body.night .coin-heads {
      background: linear-gradient(45deg, #505050, #707070, #505050);
      border: 8px solid #454545;
      color: #ddd;
    }
    
    body.night .coin-tails {
      background: linear-gradient(45deg, #b08f2d, #d3b764, #b08f2d);
      border: 8px solid #9e7f28;
      color: #fff4d1;
    }
    
    .coin-shine {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: radial-gradient(
        ellipse at center,
        rgba(255, 255, 255, 0.7) 0%,
        rgba(255, 255, 255, 0.5) 25%,
        rgba(255, 255, 255, 0) 60%
      );
      pointer-events: none;
    }
    
    body.night .coin-shine {
      background: radial-gradient(
        ellipse at center,
        rgba(255, 255, 255, 0.3) 0%,
        rgba(255, 255, 255, 0.2) 25%,
        rgba(255, 255, 255, 0) 60%
      );
    }
    
    .coin-shadow {
      position: absolute;
      width: 150px;
      height: 20px;
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0) 70%);
      border-radius: 50%;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%);
      z-index: -1;
      transition: all 0.3s ease;
    }
    
    body.night .coin-shadow {
      background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0) 70%);
    }
    
    @media (max-width: 768px) {
      .coin-animation-container {
        height: 180px;
        margin: 20px auto 50px; /* Increased bottom margin from 30px to 50px */
      }
      
      .coin {
        width: 120px;
        height: 120px;
      }
      
      .coin-shadow {
        width: 120px;
        bottom: -25px;
      }
      
      .coin-face {
        font-size: 24px;
      }
    }
  </style>
</head>
<body class="day">
  <div class="container">
    <div class="row">
      <div class="three columns icon">
        <img src="images/moon.svg" id="moon">
        <img src="images/sun.svg" id="sun">
      </div>
      
      <div class="nine columns">
        <button class="back-button" onclick="window.location.href='index.html'">Retour à l'accueil</button>
      </div>
    </div>
    
    <div class="clt-container animated fadeIn one">
      <div class="clt-header">
        <h1>Théorème Central Limite - Illustration</h1>
        <p class="animated fadeIn two" style="text-align: justify;">Cette visualisation interactive illustre le théorème central limite avec un exemple simple : le lancer de pièce (pile ou face). Observez comment la distribution des moyennes d'échantillons se rapproche d'une distribution normale quand la taille des échantillons augmente.</p>
        
        <!-- Add coin animation here -->
        <div class="coin-animation-container animated fadeIn three">
          <div class="coin">
            <div class="coin-face coin-heads">
              <span>P</span>
              <div class="coin-shine"></div>
            </div>
            <div class="coin-face coin-tails">
              <span>F</span>
              <div class="coin-shine"></div>
            </div>
          </div>
          <div class="coin-shadow"></div>
        </div>
        
        <div class="info-panel animated fadeIn three" style="text-align: justify;">
          <p>Imaginons que nous lancions une pièce équilibrée plusieurs fois et que nous calculions la moyenne des résultats (0 pour pile, 1 pour face). Selon le théorème central limite, la distribution de ces moyennes va tendre vers une loi normale quand nous répétons cette expérience un grand nombre de fois.</p>
          <p>Si \(X_1, X_2, \ldots, X_n\) sont des variables aléatoires indépendantes et identiquement distribuées où chaque \(X_i\) vaut 0 (pile) ou 1 (face) avec probabilité 0.5, alors la somme normalisée:</p>
          <p>\[ Z_n = \frac{\sum_{i=1}^{n} X_i - n \cdot 0.5}{\sqrt{n \cdot 0.5 \cdot 0.5}} \]</p>
          <p>converge en loi vers une variable aléatoire normale centrée réduite \(\mathcal{N}(0,1)\) quand \(n\) tend vers l'infini.</p>
        </div>
        
        <div class="visualization-single animated fadeIn four">
          <div class="visualization-card">
            <h3>Distribution des moyennes d'échantillons</h3>
            <div id="sample-means-distribution" class="visualization-container"></div>
            
            <!-- Add the slider controls here, below the visualization -->
            <div class="control-group" style="margin-top: 20px;">
              <label for="sample-size">Taille de l'échantillon (nombre de lancers):</label>
              <div class="sample-size-display">
                <input type="number" id="sample-size-input" min="1" max="300" value="30">
                <span id="sample-size-value">30</span>
              </div>
              <div class="slider-container">
                <input type="range" id="sample-size" min="1" max="300" value="30" step="1">
              </div>
            </div>
            
            <p class="description">Ce graphique montre la distribution des moyennes obtenues pour chaque expérience (série de lancers). Observez comme elle se rapproche d'une distribution normale (courbe rouge en pointillé) lorsque la taille de l'échantillon augmente.</p>
            <div class="stat-display">
              <div class="stat-item">
                <span class="stat-label">Moyenne théorique:</span>
                <span id="theoretical-mean" class="stat-value">0.5</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">Écart-type théorique:</span>
                <span id="theoretical-sd" class="stat-value">-</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Détection du mode jour/nuit
    function isDarkMode() {
      return document.body.classList.contains('night');
    }

    // Synchronisation du mode thème avec la page principale
    (function() {
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme === 'night') {
        document.body.classList.remove('day');
        document.body.classList.add('night');
      }
    })();

    document.addEventListener('DOMContentLoaded', function() {
      // Variables et configurations
      let sampleSize = parseInt(document.getElementById('sample-size').value);
      const numExperiments = 10000; // Nombre d'expériences fixé à 10000
      let svg, width, height;
      
      // Setup the input field to sync with the slider
      const sampleSizeSlider = document.getElementById('sample-size');
      const sampleSizeInput = document.getElementById('sample-size-input');
      
      // Update input when slider changes
      sampleSizeSlider.addEventListener('input', function() {
        sampleSize = parseInt(this.value);
        sampleSizeInput.value = sampleSize;
        updateVisualization();
      });
      
      // Update slider when input changes
      sampleSizeInput.addEventListener('change', function() {
        let value = parseInt(this.value);
        
        // Validate the input value
        if (isNaN(value)) {
          value = 30; // Default value
        }
        
        // Enforce min and max constraints
        value = Math.max(1, Math.min(300, value));// Changed from 1000 to 300
        
        // Update the input field with the validated value
        this.value = value;
        
        // Update the slider value
        sampleSizeSlider.value = value;
        sampleSize = value;
        updateVisualization();
      });
      
      // Prevent non-numeric input
      sampleSizeInput.addEventListener('keypress', function(event) {
        const charCode = (event.which) ? event.which : event.keyCode;
        if (charCode > 31 && (charCode < 48 || charCode > 57)) {
          event.preventDefault();
        }
      });
      
      // Handle Enter key press
      sampleSizeInput.addEventListener('keyup', function(event) {
        if (event.key === 'Enter') {
          this.blur(); // Remove focus to trigger the change event
        }
      });
      
      // Fonction pour initialiser ou rafraîchir la taille du SVG
      function setupSvgDimensions() {
        const container = document.getElementById('sample-means-distribution');
        if (!container) return;
        
        // Nettoyer l'ancien SVG s'il existe
        d3.select('#sample-means-distribution svg').remove();
        
        // Configurations des marges et dimensions
        const margin = {
          top: 20, 
          right: 30, 
          bottom: 40, 
          left: isMobile() ? 40 : 50
        };
        
        // Obtenir la taille du conteneur (peut changer lors du redimensionnement)
        width = container.clientWidth - margin.left - margin.right;
        height = container.clientHeight - margin.top - margin.bottom;
        
        // Vérifier que les dimensions sont valides (important sur mobile)
        if (width <= 0 || height <= 0) {
          console.log("Invalid dimensions, retrying...");
          // Sur certains appareils, il faut un peu plus de temps pour que les dimensions soient calculées
          setTimeout(setupSvgDimensions, 100);
          return;
        }
        
        // Créer le SVG avec les bonnes dimensions
        svg = d3.select('#sample-means-distribution')
          .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
            .attr('preserveAspectRatio', 'xMidYMid meet')
          .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
            
        // Générer la visualisation
        updateVisualization();
      }
      
      // Détecter si on est sur mobile
      function isMobile() {
        return window.innerWidth <= 768;
      }
      
      // Tooltip pour les informations au survol
      const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);
      
      // Générer des échantillons pile ou face et calculer les moyennes
      function generateSampleMeans(sampleSize, numExperiments) {
        const means = [];
        
        for (let i = 0; i < numExperiments; i++) {
          let sum = 0;
          
          // Simuler sampleSize lancers
          for (let j = 0; j < sampleSize; j++) {
            // 0 pour pile, 1 pour face avec probabilité 0.5
            sum += (Math.random() < 0.5) ? 0 : 1;
          }
          
          // Calculer la moyenne de cet échantillon
          const mean = sum / sampleSize;
          means.push(mean);
        }
        
        return means;
      }
      
      // Mettre à jour la visualisation des moyennes d'échantillons
      function updateSampleMeansDistribution(means) {
        if (!svg || !width || !height) return;
        
        svg.selectAll('*').remove();
        
        // Calcul des statistiques
        const meanOfMeans = d3.mean(means);
        const stdOfMeans = d3.deviation(means);
        const theoreticalMean = 0.5; // Pour une pièce équilibrée
        const theoreticalStd = Math.sqrt(0.25 / sampleSize); // sqrt(p*(1-p)/n)
        
        // Affichage de l'écart-type théorique
        document.getElementById('theoretical-sd').textContent = theoreticalStd.toFixed(4);
        
        // Pour un lancer de pièce équilibrée, les moyennes possibles sont:
        // 0/n, 1/n, 2/n, ..., n/n où n est la taille de l'échantillon
        // Donc exactement n+1 valeurs possibles
        
        // Créer des seuils explicites correspondant aux valeurs possibles
        const thresholds = [];
        for (let i = 0; i <= sampleSize; i++) {
          thresholds.push(i / sampleSize);
        }
        
        // Calculer les quantiles à 1% et 99% pour la loi normale
        const quantile01 = theoreticalMean - 3.326 * theoreticalStd;
        const quantile99 = theoreticalMean + 3.326 * theoreticalStd;
        
        // Déterminer la plus petite fenêtre entre les quantiles et la fenêtre fixe
        const fixedRange = [-0.03, 1.03];
        const normalRange = [quantile01, quantile99];
        
        // Choisir la fenêtre la plus petite
        const xMin = Math.max(fixedRange[0], normalRange[0]);
        const xMax = Math.min(fixedRange[1], normalRange[1]);
        
        // Ajouter un léger padding pour éviter de couper les barres
        const padding = 0.5 / sampleSize;
        
        // Échelles avec domaine adapté
        const x = d3.scaleLinear()
          .domain([xMin - padding, xMax + padding])
          .range([0, width]);
        
        // Créer l'histogramme avec exactement les seuils correspondant aux valeurs possibles
        const histogram = d3.histogram()
          .value(d => d)
          .domain(x.domain())
          .thresholds(thresholds);
          
        const bins = histogram(means);
        if (bins.length === 0 || !bins[0]) return; // Protection contre les erreurs
                
        const y = d3.scaleLinear()
          .domain([0, d3.max(bins, d => d.length) / means.length * 1.1])
          .nice()
          .range([height, 0]);
          
        // Axes avec graduations adaptées à la taille de l'échantillon
        const xAxis = d3.axisBottom(x);
        
        // Adapter le nombre de ticks en fonction de la taille de l'échantillon
        if (sampleSize <= 20) {
          // Pour les petits échantillons, montrer toutes les valeurs possibles
          xAxis.tickValues(thresholds);
        } else if (sampleSize <= 100) {
          // Pour les échantillons moyens, montrer un sous-ensemble équilibré
          const step = Math.ceil(sampleSize / 10);
          const tickValues = [];
          for (let i = 0; i <= sampleSize; i += step) {
            tickValues.push(i / sampleSize);
          }
          // S'assurer que 0.5 est inclus
          if (!tickValues.includes(0.5)) {
            tickValues.push(0.5);
          }
          tickValues.sort((a, b) => a - b);
          xAxis.tickValues(tickValues);
        } else {
          // Pour les grands échantillons, laisser D3 choisir
          xAxis.ticks(isMobile() ? 5 : 10);
        }
        
        // Format des ticks pour les grands nombres
        if (sampleSize > 20) {
          xAxis.tickFormat(d3.format('.2f'));
        }
        
        svg.append('g')
          .attr('class', 'axis')
          .attr('transform', `translate(0,${height})`)
          .call(xAxis);
          
        svg.append('g')
          .attr('class', 'axis')
          .call(d3.axisLeft(y).ticks(5).tickFormat(d3.format('.1%')));
        
        // Barres de l'histogramme
        svg.selectAll('rect')
          .data(bins)
          .enter()
          .append('rect')
            .attr('class', 'histogram-rect')
            .attr('x', d => x(d.x0 - 0.5/sampleSize)) // Shift boxes to align with actual value
            .attr('y', d => y(d.length / means.length))
            .attr('width', d => {
              // Calculate width properly accounting for the shift
              // Each bin should have equal width of 1/sampleSize
              return Math.max(1, x(d.x0 + 1/sampleSize) - x(d.x0));
            })
            .attr('height', d => height - y(d.length / means.length))
            .attr('fill', isDarkMode() ? '#5d9cfa' : '#4a89dc')
            .on('mouseover touchstart', function(event, d) {
              const binMean = (d.x0 + d.x1) / 2;
              const frequency = d.length / means.length;
              
              tooltip.html(`
                <strong>Moyenne:</strong> ${binMean.toFixed(3)}<br>
                <strong>Fréquence:</strong> ${(frequency * 100).toFixed(2)}%
              `)
              .style('left', (event.pageX || event.changedTouches?.[0]?.pageX) + 'px')
              .style('top', ((event.pageY || event.changedTouches?.[0]?.pageY) - 28) + 'px')
              .style('opacity', 1)
              .classed('visible', true);
              
              d3.select(this).attr('opacity', 0.7);
            })
            .on('mouseout touchend', function() {
              tooltip.classed('visible', false)
                .style('opacity', 0);
              d3.select(this).attr('opacity', 1);
            });
            
        // Calculer les points de la courbe normale théorique adaptés aux bins
        const normalPoints = [];
        for (let i = 0; i <= width; i += 2) { // Réduire le nombre de points pour plus d'efficacité
          const x0 = x.invert(i);
          // PDF pour la distribution normale
          const pdf = (1 / (theoreticalStd * Math.sqrt(2 * Math.PI))) *
                    Math.exp(-0.5 * Math.pow((x0 - theoreticalMean) / theoreticalStd, 2));
          // Mettre à l'échelle pour correspondre aux fréquences relatives
          const binWidth = 1 / sampleSize;
          const scaledPdf = pdf * binWidth;
          normalPoints.push([i, y(scaledPdf)]);
        }
        
        const line = d3.line();
        
        // Ajout de la courbe avec animation
        const path = svg.append('path')
          .datum(normalPoints)
          .attr('class', 'normal-curve')
          .attr('d', line);
          
        // Animation de traçage de la courbe
        const totalLength = path.node().getTotalLength();
        path
          .attr('stroke-dasharray', totalLength + ' ' + totalLength)
          .attr('stroke-dashoffset', totalLength)
          .transition()
            .duration(800)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);
            
        // Légendes
        svg.append('text')
          .attr('transform', `translate(${width/2}, ${height + (isMobile() ? 30 : 35)})`)
          .style('text-anchor', 'middle')
          .attr('class', 'axis-label')
          .text('Moyenne d\'échantillon');
          
        svg.append('text')
          .attr('transform', 'rotate(-90)')
          .attr('y', isMobile() ? -30 : -40)
          .attr('x', -height/2)
          .style('text-anchor', 'middle')
          .attr('class', 'axis-label')
          .text('Fréquence');
        
        // Légende pour la courbe normale - adaptée pour mobile
        if (!isMobile()) {
          svg.append('line')
            .attr('x1', width - 120)
            .attr('y1', 20)
            .attr('x2', width - 80)
            .attr('y2', 20)
            .attr('stroke', isDarkMode() ? '#ff8787' : '#ff6b6b')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,3');
            
          svg.append('text')
            .attr('x', width - 70)
            .attr('y', 24)
            .style('font-size', '10px')
            .text('Distribution normale théorique');
        } else {
          // Version compacte pour mobile
          svg.append('line')
            .attr('x1', width - 85)
            .attr('y1', 15)
            .attr('x2', width - 60)
            .attr('y2', 15)
            .attr('stroke', isDarkMode() ? '#ff8787' : '#ff6b6b')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,3');
            
          svg.append('text')
            .attr('x', width - 50)
            .attr('y', 18)
            .style('font-size', '8px')
            .text('Normale théorique');
        }
      }
      
      // Fonction pour mettre à jour la visualisation
      function updateVisualization() {
        const means = generateSampleMeans(sampleSize, numExperiments);
        updateSampleMeansDistribution(means);
      }
      
      // Événements pour les contrôles
      document.getElementById('sample-size').addEventListener('input', function() {
        sampleSize = parseInt(this.value);
        document.getElementById('sample-size-value').textContent = sampleSize;
        updateVisualization();
      });
      
      // Gestion du redimensionnement de la fenêtre
      let resizeTimeout;
      function handleResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          setupSvgDimensions();
        }, 250);
      }
      
      window.addEventListener('resize', handleResize);
      
      // Gérer les changements d'orientation sur mobile
      window.addEventListener('orientationchange', function() {
        // Attendre que le navigateur ait fini de recalculer les dimensions
        setTimeout(setupSvgDimensions, 300);
      });
      
      // Assurer une hauteur minimale pour le conteneur
      const container = document.querySelector('.visualization-container');
      if (container && isMobile()) {
        container.style.height = '250px'; // Hauteur fixe plus petite sur mobile
      }
      
      // Initialisation
      // Attendre un peu pour s'assurer que le DOM est bien chargé et dimensionné
      setTimeout(setupSvgDimensions, 100);
    });

    // Update tooltip handling to use smooth animations
    function showTooltip(event, d) {
      tooltip.html(`
        <strong>Moyenne:</strong> ${((d.x0 + d.x1) / 2).toFixed(3)}<br>
        <strong>Fréquence:</strong> ${(d.length / means.length * 100).toFixed(2)}%
      `)
      .style('left', (event.pageX ? event.pageX : event.changedTouches[0].pageX) + 'px')
      .style('top', ((event.pageY ? event.pageY : event.changedTouches[0].pageY) - 28) + 'px')
      .style('opacity', 1)
      .classed('visible', true);
      
      d3.select(this).attr('opacity', 0.7);
    }
    
    function hideTooltip() {
      tooltip.classed('visible', false)
        .style('opacity', 0);
      d3.select(this).attr('opacity', 1);
    }

    // Coin flip animation controlled by scrolling
    document.addEventListener('DOMContentLoaded', function() {
      const coin = document.querySelector('.coin');
      const coinContainer = document.querySelector('.coin-animation-container');
      const coinShadow = document.querySelector('.coin-shadow');
      let lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
      let flipRotation = 0;
      const flipFactor = 1; // How fast the coin flips during scroll (reduced from 5)
      
      // Set initial coin rotation
      updateCoinRotation(0);
      
      // Listen for scroll events
      window.addEventListener('scroll', function() {
        if (!coinContainer) return;
        
        const containerRect = coinContainer.getBoundingClientRect();
        const containerTop = containerRect.top;
        const containerBottom = containerRect.bottom;
        const windowHeight = window.innerHeight;
        
        // Check if coin is visible
        if (containerTop < windowHeight && containerBottom > 0) {
          const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
          const scrollDirection = currentScrollTop > lastScrollTop ? 1 : -1;
          const scrollDelta = Math.abs(currentScrollTop - lastScrollTop);
          
          // Update coin rotation based on scroll direction and delta
          if (scrollDelta > 1) { // Avoid tiny scroll adjustments
            flipRotation += scrollDirection * scrollDelta * flipFactor;
            updateCoinRotation(flipRotation);
          }
          
          lastScrollTop = currentScrollTop;
        }
      }, { passive: true });
      
      // Function to update coin rotation and shadow
      function updateCoinRotation(rotation) {
        if (!coin || !coinShadow) return;
        
        const normalizedRotation = rotation % 360;
        const isFaceUp = normalizedRotation < 90 || normalizedRotation > 270;
        
        // Rotate the coin
        coin.style.transform = `rotateY(${rotation}deg)`;
        
        // Adjust shadow based on coin orientation
        const shadowScale = Math.abs(Math.sin(rotation * Math.PI / 180)) * 0.3 + 0.7;
        const shadowOpacity = isFaceUp ? 0.4 : 0.3;
        
        coinShadow.style.transform = `translateX(-50%) scale(${shadowScale}, 1)`;
        coinShadow.style.opacity = shadowOpacity.toString();
      }
      
      // Allow direct interaction with the coin as well
      coin.addEventListener('click', function() {
        flipRotation += 180;
        updateCoinRotation(flipRotation);
      });
    });
  </script>
</body>
</html>
