<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Théorème Central Limite - Illustration avec Pile ou Face</title>
  <meta name="description" content="Illustration interactive du théorème central limite avec des lancers de pièce">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/animate.css">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/dot.png">

  <!-- D3.js pour les visualisations -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <!-- MathJax pour les formules mathématiques -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="day">
  <div class="container">
    <button class="back-button" onclick="window.location.href='index.html'">Retour à l'accueil</button>
    
    <div class="clt-container animated fadeIn one">
      <div class="clt-header">
        <h1>Théorème Central Limite - Pile ou Face</h1>
        <p class="animated fadeIn two">Cette visualisation interactive illustre le théorème central limite avec un exemple simple: le lancer de pièce (pile ou face). Observez comment la distribution des moyennes d'échantillons se rapproche d'une distribution normale quand la taille des échantillons augmente.</p>
      </div>
      
      <div class="info-panel animated fadeIn three">
        <p>Imaginons que nous lancions une pièce équilibrée plusieurs fois et que nous calculions la moyenne des résultats (0 pour pile, 1 pour face). Selon le théorème central limite, la distribution de ces moyennes va tendre vers une loi normale quand nous répétons cette expérience un grand nombre de fois.</p>
        <p>Si \(X_1, X_2, \ldots, X_n\) sont des variables aléatoires indépendantes et identiquement distribuées où chaque \(X_i\) vaut 0 (pile) ou 1 (face) avec probabilité 0.5, alors la somme normalisée:</p>
        <p>\[ Z_n = \frac{\sum_{i=1}^{n} X_i - n \cdot 0.5}{\sqrt{n \cdot 0.5 \cdot 0.5}} \]</p>
        <p>converge en loi vers une variable aléatoire normale centrée réduite \(\mathcal{N}(0,1)\) quand \(n\) tend vers l'infini.</p>
      </div>
      
      <div class="controls-panel animated fadeIn three">
        <div class="control-group">
          <label for="sample-size">Taille de l'échantillon (nombre de lancers): <span id="sample-size-value">30</span></label>
          <div class="slider-container">
            <input type="range" id="sample-size" min="1" max="1000" value="30" step="1">
          </div>
        </div>
        
        <div class="control-group">
          <label for="num-experiments">Nombre d'expériences: <span id="num-experiments-value">1000</span></label>
          <div class="slider-container">
            <input type="range" id="num-experiments" min="100" max="5000" value="1000" step="100">
          </div>
        </div>
      </div>
      
      <div class="visualization-single animated fadeIn four">
        <div class="visualization-card">
          <h3>Distribution des moyennes d'échantillons</h3>
          <div id="sample-means-distribution" class="visualization-container"></div>
          <p class="description">Ce graphique montre la distribution des moyennes obtenues pour chaque expérience (série de lancers). Observez comme elle se rapproche d'une distribution normale (courbe rouge en pointillé) lorsque la taille de l'échantillon augmente.</p>
          <div class="stat-display">
            <div class="stat-item">
              <span class="stat-label">Moyenne théorique:</span>
              <span id="theoretical-mean" class="stat-value">0.5</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Écart-type théorique:</span>
              <span id="theoretical-sd" class="stat-value">-</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Détection du mode jour/nuit
    function isDarkMode() {
      return document.body.classList.contains('night');
    }

    // Synchronisation du mode thème avec la page principale
    (function() {
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme === 'night') {
        document.body.classList.remove('day');
        document.body.classList.add('night');
      }
    })();

    document.addEventListener('DOMContentLoaded', function() {
      // Variables et configurations
      let sampleSize = parseInt(document.getElementById('sample-size').value);
      let numExperiments = parseInt(document.getElementById('num-experiments').value);
      
      // Configurations des marges et dimensions
      const margin = {top: 20, right: 30, bottom: 40, left: 50};
      const width = document.getElementById('sample-means-distribution').clientWidth - margin.left - margin.right;
      const height = document.getElementById('sample-means-distribution').clientHeight - margin.top - margin.bottom;
      
      // Création du SVG pour la visualisation
      const svg = d3.select('#sample-means-distribution')
        .append('svg')
          .attr('width', width + margin.left + margin.right)
          .attr('height', height + margin.top + margin.bottom)
        .append('g')
          .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Tooltip pour les informations au survol
      const tooltip = d3.select('body').append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);
      
      // Générer des échantillons pile ou face et calculer les moyennes
      function generateSampleMeans(sampleSize, numExperiments) {
        const means = [];
        
        for (let i = 0; i < numExperiments; i++) {
          let sum = 0;
          
          // Simuler sampleSize lancers
          for (let j = 0; j < sampleSize; j++) {
            // 0 pour pile, 1 pour face avec probabilité 0.5
            sum += (Math.random() < 0.5) ? 0 : 1;
          }
          
          // Calculer la moyenne de cet échantillon
          const mean = sum / sampleSize;
          means.push(mean);
        }
        
        return means;
      }
      
      // Mettre à jour la visualisation des moyennes d'échantillons
      function updateSampleMeansDistribution(means) {
        svg.selectAll('*').remove();
        
        // Calcul des statistiques
        const meanOfMeans = d3.mean(means);
        const stdOfMeans = d3.deviation(means);
        const theoreticalMean = 0.5; // Pour une pièce équilibrée
        const theoreticalStd = Math.sqrt(0.25 / sampleSize); // sqrt(p*(1-p)/n)
        
        // Affichage de l'écart-type théorique
        document.getElementById('theoretical-sd').textContent = theoreticalStd.toFixed(4);
        
        // Échelles
        const xExtent = [
          Math.min(d3.min(means), theoreticalMean - 3.5 * theoreticalStd),
          Math.max(d3.max(means), theoreticalMean + 3.5 * theoreticalStd)
        ];
        
        const x = d3.scaleLinear()
          .domain(xExtent)
          .nice()
          .range([0, width]);
          
        // Créer l'histogramme
        const histogram = d3.histogram()
          .value(d => d)
          .domain(x.domain())
          .thresholds(x.ticks(30));
          
        const bins = histogram(means);
        const binWidth = bins[0].x1 - bins[0].x0;
        
        const y = d3.scaleLinear()
          .domain([0, d3.max(bins, d => d.length) / means.length * 1.1])
          .nice()
          .range([height, 0]);
          
        // Axes
        svg.append('g')
          .attr('class', 'axis')
          .attr('transform', `translate(0,${height})`)
          .call(d3.axisBottom(x).ticks(8));
          
        svg.append('g')
          .attr('class', 'axis')
          .call(d3.axisLeft(y).ticks(5).tickFormat(d3.format('.1%')));
        
        // Barres de l'histogramme
        svg.selectAll('rect')
          .data(bins)
          .enter()
          .append('rect')
            .attr('class', 'histogram-rect')
            .attr('x', d => x(d.x0) + 1)
            .attr('y', d => y(d.length / means.length))
            .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 2))
            .attr('height', d => height - y(d.length / means.length))
            .attr('fill', isDarkMode() ? '#5d9cfa' : '#4a89dc')
            .on('mouseover', function(event, d) {
              tooltip.transition()
                .duration(200)
                .style('opacity', 0.9);
              tooltip.html(`
                <strong>Moyenne:</strong> ${((d.x0 + d.x1) / 2).toFixed(3)}<br>
                <strong>Fréquence:</strong> ${(d.length / means.length * 100).toFixed(2)}%
              `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 28) + 'px');
              d3.select(this).attr('opacity', 0.7);
            })
            .on('mouseout', function() {
              tooltip.transition()
                .duration(500)
                .style('opacity', 0);
              d3.select(this).attr('opacity', 1);
            });
            
        // Courbe normale théorique
        const normalPoints = [];
        for (let i = 0; i <= width; i++) {
          const x0 = x.invert(i);
          // Compute the PDF for the normal distribution and scale by bin width
          const pdf = (1 / (theoreticalStd * Math.sqrt(2 * Math.PI))) *
                    Math.exp(-0.5 * Math.pow((x0 - theoreticalMean) / theoreticalStd, 2));
          const scaledPdf = pdf * binWidth; // Scale to match the histogram's relative frequencies
          normalPoints.push([i, y(scaledPdf)]);
        }
        
        const line = d3.line();
        
        // Ajout de la courbe avec animation
        const path = svg.append('path')
          .datum(normalPoints)
          .attr('class', 'normal-curve')
          .attr('d', line);
          
        // Animation de traçage de la courbe
        const totalLength = path.node().getTotalLength();
        path
          .attr('stroke-dasharray', totalLength + ' ' + totalLength)
          .attr('stroke-dashoffset', totalLength)
          .transition()
            .duration(800)
            .ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);
            
        // Légendes
        svg.append('text')
          .attr('transform', `translate(${width/2}, ${height + margin.bottom - 5})`)
          .style('text-anchor', 'middle')
          .attr('class', 'axis-label')
          .text('Moyenne d\'échantillon');
          
        svg.append('text')
          .attr('transform', 'rotate(-90)')
          .attr('y', -margin.left + 15)
          .attr('x', -height/2)
          .style('text-anchor', 'middle')
          .attr('class', 'axis-label')
          .text('Fréquence');
          
        // Ligne verticale pour la moyenne théorique
        svg.append('line')
          .attr('x1', x(theoreticalMean))
          .attr('y1', 0)
          .attr('x2', x(theoreticalMean))
          .attr('y2', height)
          .attr('stroke', isDarkMode() ? '#ff8787' : '#ff6b6b')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '3,3');
          
        // Annotation de la moyenne théorique
        svg.append('text')
          .attr('x', x(theoreticalMean))
          .attr('y', 10)
          .attr('text-anchor', 'middle')
          .style('font-family', 'NeueHaasMedium')
          .style('font-size', '11px')
          .text(`μ = 0.5`);
          
        // Légende pour la courbe normale
        svg.append('line')
          .attr('x1', width - 120)
          .attr('y1', 20)
          .attr('x2', width - 80)
          .attr('y2', 20)
          .attr('stroke', isDarkMode() ? '#ff8787' : '#ff6b6b')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,3');
          
        svg.append('text')
          .attr('x', width - 70)
          .attr('y', 24)
          .style('font-size', '10px')
          .text('Distribution normale théorique');
      }
      
      // Fonction pour mettre à jour la visualisation
      function updateVisualization() {
        const means = generateSampleMeans(sampleSize, numExperiments);
        updateSampleMeansDistribution(means);
      }
      
      // Événements
      document.getElementById('sample-size').addEventListener('input', function() {
        sampleSize = parseInt(this.value);
        document.getElementById('sample-size-value').textContent = sampleSize;
        updateVisualization();
      });
      
      document.getElementById('num-experiments').addEventListener('input', function() {
        numExperiments = parseInt(this.value);
        document.getElementById('num-experiments-value').textContent = numExperiments;
        updateVisualization();
      });
      
      // Initialisation
      window.addEventListener('resize', updateVisualization);
      
      // Première génération
      updateVisualization();
    });
  </script>

  <style>
    /* Styles spécifiques à cette page */
    .visualization-single {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .stat-display {
      display: flex;
      justify-content: space-around;
      margin-top: 15px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-label {
      font-family: NeueHaasMedium;
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-family: NeueHaasMedium;
      font-size: 18px;
      color: #4a89dc;
    }
    
    body.night .stat-value {
      color: #5d9cfa;
    }
    
    .axis-label {
      font-family: NeueHaas;
      font-size: 11px;
      fill: #8A898C;
    }
    
    body.night .axis-label {
      fill: #C8C8C9;
    }
    
    .normal-curve {
      stroke: #ff6b6b;
      stroke-width: 2;
      stroke-dasharray: 5,3;
      fill: none;
    }
    
    body.night .normal-curve {
      stroke: #ff8787;
    }
  </style>
</body>
</html>
